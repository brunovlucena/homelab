"""
Exploit Generator - LLM-powered exploit PoC generation.

SAFETY: All exploits run ONLY on local Anvil forks.
"""
import os
import re
import json
import asyncio
import tempfile
from typing import Optional
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

import httpx
import structlog
from cloudevents.http import CloudEvent

from shared.metrics import (
    EXPLOITS_GENERATED,
    EXPLOITS_VALIDATED,
    EXPLOITS_FAILED_VALIDATION,
    EXPLOIT_VALIDATION_DURATION,
    LLM_TOKENS_USED,
)

logger = structlog.get_logger()

# Safety: Allowed RPC endpoints (Anvil only)
ALLOWED_RPC_ENDPOINTS = [
    "http://anvil:8545",
    "http://localhost:8545",
    "http://127.0.0.1:8545",
]


class ExploitStatus(str, Enum):
    GENERATED = "generated"
    VALIDATED = "validated"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class ExploitResult:
    """Result of exploit generation and validation."""
    chain: str
    contract_address: str
    vulnerability_type: str
    exploit_code: Optional[str] = None
    status: ExploitStatus = ExploitStatus.GENERATED
    validation_result: Optional[dict] = None
    profit_potential: Optional[str] = None
    gas_used: Optional[int] = None
    error: Optional[str] = None
    model_used: str = "local"
    
    def to_dict(self) -> dict:
        return {
            "chain": self.chain,
            "contract_address": self.contract_address,
            "vulnerability_type": self.vulnerability_type,
            "exploit_code": self.exploit_code,
            "status": self.status.value,
            "validation_result": self.validation_result,
            "profit_potential": self.profit_potential,
            "gas_used": self.gas_used,
            "error": self.error,
            "model_used": self.model_used,
        }


class ExploitGenerator:
    """Generate exploit PoCs using LLM."""
    
    FOUNDRY_TEST_TEMPLATE = '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IVulnerableContract {{
    {interface_functions}
}}

contract ExploitTest is Test {{
    IVulnerableContract target;
    address attacker = makeAddr("attacker");
    
    function setUp() public {{
        // Fork mainnet at current block
        vm.createSelectFork(vm.envString("RPC_URL"));
        target = IVulnerableContract({contract_address});
    }}
    
    function testExploit() public {{
        uint256 attackerBalanceBefore = attacker.balance;
        
        vm.startPrank(attacker);
        
        {exploit_logic}
        
        vm.stopPrank();
        
        uint256 attackerBalanceAfter = attacker.balance;
        
        // Assert exploit succeeded
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Exploit should increase attacker balance");
    }}
}}
'''

    def __init__(
        self,
        ollama_url: str = None,
        anthropic_key: str = None,
        anvil_url: str = None,
    ):
        self.ollama_url = ollama_url or os.getenv("OLLAMA_URL", "http://ollama-native.ollama.svc.cluster.local:11434")
        self.anthropic_key = anthropic_key or os.getenv("ANTHROPIC_API_KEY")
        self.anvil_url = anvil_url or os.getenv("ANVIL_URL", "http://anvil:8545")
        
        # Validate Anvil URL is allowed
        if self.anvil_url not in ALLOWED_RPC_ENDPOINTS:
            raise ValueError(f"RPC endpoint {self.anvil_url} not in allowed list. Safety restriction.")
    
    async def generate(
        self,
        chain: str,
        contract_address: str,
        source_code: str,
        vulnerability: dict,
        abi: Optional[list] = None,
    ) -> ExploitResult:
        """
        Generate and validate exploit for a vulnerability.
        
        Args:
            chain: Target chain (ethereum, bsc, etc.)
            contract_address: Contract address
            source_code: Solidity source code
            vulnerability: Vulnerability details from scanner
            abi: Contract ABI (optional)
        """
        log = logger.bind(
            chain=chain,
            address=contract_address,
            vuln_type=vulnerability.get("type")
        )
        log.info("exploit_generation_started")
        
        result = ExploitResult(
            chain=chain,
            contract_address=contract_address,
            vulnerability_type=vulnerability.get("type", "unknown"),
        )
        
        try:
            # Generate exploit using LLM
            exploit_code = await self._generate_with_llm(
                source_code,
                vulnerability,
                contract_address,
                abi,
            )
            
            if not exploit_code:
                result.status = ExploitStatus.FAILED
                result.error = "LLM failed to generate exploit"
                return result
            
            result.exploit_code = exploit_code
            result.status = ExploitStatus.GENERATED
            
            # Validate on Anvil fork
            with EXPLOIT_VALIDATION_DURATION.labels(chain=chain).time():
                validation = await self._validate_on_anvil(
                    chain,
                    contract_address,
                    exploit_code,
                )
            
            result.validation_result = validation
            if validation.get("success"):
                result.status = ExploitStatus.VALIDATED
                result.profit_potential = validation.get("profit")
                result.gas_used = validation.get("gas_used")
                log.info("exploit_validated", profit=result.profit_potential)
            else:
                result.status = ExploitStatus.FAILED
                result.error = validation.get("error", "Validation failed")
                log.warning("exploit_validation_failed", error=result.error)
            
            # Record metrics - use correct shared metrics labels
            if result.status == ExploitStatus.VALIDATED:
                EXPLOITS_GENERATED.labels(chain=chain, status="success").inc()
                EXPLOITS_VALIDATED.labels(
                    chain=chain,
                    vuln_type=vulnerability.get("type", "unknown"),
                    profit_potential=result.profit_potential or "unknown",
                    contract_address=contract_address,
                ).inc()
            elif result.status == ExploitStatus.FAILED:
                EXPLOITS_GENERATED.labels(chain=chain, status="failed").inc()
                if result.validation_result:
                    EXPLOITS_FAILED_VALIDATION.labels(
                        chain=chain,
                        vuln_type=vulnerability.get("type", "unknown"),
                    ).inc()
            else:
                EXPLOITS_GENERATED.labels(chain=chain, status="success").inc()
            
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error = str(e)
            log.error("exploit_generation_failed", error=str(e))
        
        return result
    
    async def _generate_with_llm(
        self,
        source_code: str,
        vulnerability: dict,
        contract_address: str,
        abi: Optional[list],
    ) -> Optional[str]:
        """Generate exploit code using LLM."""
        prompt = self._build_prompt(source_code, vulnerability, contract_address, abi)
        
        # Try local Ollama first
        response = await self._query_ollama(prompt)
        
        # Fallback to Claude for complex cases
        if not response or len(response) < 100:
            if self.anthropic_key:
                logger.info("falling_back_to_claude")
                response = await self._query_claude(prompt)
        
        if not response:
            return None
        
        # Extract Solidity code from response
        return self._extract_solidity(response)
    
    def _build_prompt(
        self,
        source_code: str,
        vulnerability: dict,
        contract_address: str,
        abi: Optional[list],
    ) -> str:
        """Build exploit generation prompt."""
        vuln_type = vulnerability.get("type", "unknown")
        description = vulnerability.get("description", "")
        location = vulnerability.get("location", "")
        
        abi_text = ""
        if abi:
            # Extract function signatures
            funcs = [f for f in abi if f.get("type") == "function"]
            abi_text = "\n".join([
                f"- {f.get('name')}({', '.join([i.get('type') for i in f.get('inputs', [])])})"
                for f in funcs[:20]  # Limit to 20 functions
            ])
        
        return f"""You are a smart contract security researcher. Generate a Foundry test that exploits the following vulnerability.

TARGET CONTRACT: {contract_address}

VULNERABILITY:
- Type: {vuln_type}
- Location: {location}
- Description: {description}

CONTRACT SOURCE (truncated):
```solidity
{source_code[:6000]}
```

{f"AVAILABLE FUNCTIONS:{chr(10)}{abi_text}" if abi_text else ""}

REQUIREMENTS:
1. Generate a complete Foundry test in Solidity
2. Use vm.createSelectFork to fork the chain
3. The test should demonstrate the vulnerability can be exploited
4. Include assertions that prove the exploit succeeded
5. Calculate profit if applicable

OUTPUT: Generate ONLY valid Solidity code. No explanations.

```solidity
// Your exploit test here
```"""

    async def _query_ollama(self, prompt: str) -> Optional[str]:
        """Query local Ollama instance."""
        try:
            async with httpx.AsyncClient(timeout=180.0) as client:
                response = await client.post(
                    f"{self.ollama_url}/api/generate",
                    json={
                        "model": os.getenv("OLLAMA_MODEL", "deepseek-coder-v2:33b"),
                        "prompt": prompt,
                        "stream": False,
                        "options": {
                            "temperature": 0.1,
                            "num_predict": 4096,
                        }
                    }
                )
                response.raise_for_status()
                
                result = response.json()
                LLM_TOKENS_USED.labels(model="ollama", type="output").inc(
                    result.get("eval_count", 0)
                )
                
                return result.get("response", "")
        except Exception as e:
            logger.error("ollama_query_failed", error=str(e))
            return None
    
    async def _query_claude(self, prompt: str) -> Optional[str]:
        """Query Claude API as fallback."""
        if not self.anthropic_key:
            return None
        
        try:
            import anthropic
            
            client = anthropic.Anthropic(api_key=self.anthropic_key)
            message = client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=4096,
                temperature=0.1,
                messages=[{"role": "user", "content": prompt}]
            )
            
            LLM_TOKENS_USED.labels(model="claude", type="output").inc(
                message.usage.output_tokens
            )
            
            return message.content[0].text
        except Exception as e:
            logger.error("claude_query_failed", error=str(e))
            return None
    
    def _extract_solidity(self, response: str) -> Optional[str]:
        """Extract Solidity code from LLM response."""
        # Try to find code block
        pattern = r'```solidity\s*(.*?)\s*```'
        match = re.search(pattern, response, re.DOTALL)
        
        if match:
            return match.group(1).strip()
        
        # Try generic code block
        pattern = r'```\s*(.*?)\s*```'
        match = re.search(pattern, response, re.DOTALL)
        
        if match:
            code = match.group(1).strip()
            if 'pragma solidity' in code or 'contract' in code:
                return code
        
        # Check if response itself looks like Solidity
        if 'pragma solidity' in response or 'contract' in response:
            return response.strip()
        
        return None
    
    async def _validate_on_anvil(
        self,
        chain: str,
        contract_address: str,
        exploit_code: str,
    ) -> dict:
        """
        Validate exploit on Anvil fork.
        
        SAFETY: This ONLY runs on local Anvil - never mainnet.
        """
        # Double-check we're using allowed endpoint
        if self.anvil_url not in ALLOWED_RPC_ENDPOINTS:
            return {"success": False, "error": "Invalid RPC endpoint"}
        
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            # Create Foundry project structure
            (tmpdir / "src").mkdir()
            (tmpdir / "test").mkdir()
            
            # Write foundry.toml
            foundry_config = f"""
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
fork_url = "{self.anvil_url}"
"""
            (tmpdir / "foundry.toml").write_text(foundry_config)
            
            # Write exploit test
            (tmpdir / "test" / "Exploit.t.sol").write_text(exploit_code)
            
            # Install forge-std (minimal)
            try:
                proc = await asyncio.create_subprocess_exec(
                    "forge", "install", "foundry-rs/forge-std", "--no-git",
                    cwd=tmpdir,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                await asyncio.wait_for(proc.communicate(), timeout=60)
            except Exception as e:
                logger.warning("forge_std_install_failed", error=str(e))
            
            # Run forge test
            try:
                env = os.environ.copy()
                env["RPC_URL"] = self.anvil_url
                
                proc = await asyncio.create_subprocess_exec(
                    "forge", "test", "-vvv", "--json",
                    cwd=tmpdir,
                    env=env,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                
                stdout, stderr = await asyncio.wait_for(
                    proc.communicate(),
                    timeout=300  # 5 minute timeout
                )
                
                if proc.returncode == 0:
                    # Parse test results
                    try:
                        results = json.loads(stdout.decode())
                        return {
                            "success": True,
                            "results": results,
                            "gas_used": self._extract_gas(results),
                            "profit": self._calculate_profit(results),
                        }
                    except json.JSONDecodeError:
                        return {"success": True, "raw_output": stdout.decode()[:1000]}
                else:
                    return {
                        "success": False,
                        "error": stderr.decode()[:500] or "Test failed",
                    }
                    
            except asyncio.TimeoutError:
                return {"success": False, "error": "Validation timed out"}
            except Exception as e:
                return {"success": False, "error": str(e)}
    
    def _extract_gas(self, results: dict) -> Optional[int]:
        """Extract gas used from forge test results."""
        try:
            for suite in results.values():
                for test in suite.get("test_results", {}).values():
                    if test.get("gas_used"):
                        return test["gas_used"]
        except Exception:
            pass
        return None
    
    def _calculate_profit(self, results: dict) -> Optional[str]:
        """Calculate profit from test results."""
        # This would need to parse balance changes from test logs
        # Placeholder for now
        return None


def create_exploit_validated_event(result: ExploitResult) -> CloudEvent:
    """Create CloudEvent for validated exploit."""
    attributes = {
        "type": "io.homelab.exploit.validated",
        "source": "/agent-contracts/exploit-generator",
        "subject": f"{result.chain}/{result.contract_address}",
    }
    
    return CloudEvent(attributes, result.to_dict())


def create_alert_sent_event(result: ExploitResult, severity: str) -> CloudEvent:
    """Create alert CloudEvent for critical findings."""
    attributes = {
        "type": "io.homelab.alert.sent",
        "source": "/agent-contracts/exploit-generator",
        "subject": f"{result.chain}/{result.contract_address}",
    }
    
    data = {
        "severity": severity,
        "title": f"Validated Exploit: {result.vulnerability_type}",
        "chain": result.chain,
        "contract_address": result.contract_address,
        "vulnerability_type": result.vulnerability_type,
        "profit_potential": result.profit_potential,
        "status": result.status.value,
    }
    
    return CloudEvent(attributes, data)

