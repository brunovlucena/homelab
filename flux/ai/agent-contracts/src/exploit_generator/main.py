"""
Exploit Generator - FastAPI entry point.

Handles CloudEvents for exploit generation and validation.
SAFETY: All exploits run ONLY on Anvil forks - never mainnet.
"""
import os
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.responses import JSONResponse
from cloudevents.http import from_http, to_structured, CloudEvent
from prometheus_client import generate_latest, CONTENT_TYPE_LATEST
import structlog
from opentelemetry import trace

from .handler import (
    ExploitGenerator,
    ExploitStatus,
    create_exploit_validated_event,
    create_alert_sent_event,
)
# Import metrics to ensure they're registered with Prometheus
from shared import metrics

logger = structlog.get_logger()

# Global generator
generator: ExploitGenerator = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Initialize and cleanup resources."""
    global generator
    
    try:
        generator = ExploitGenerator()
        logger.info("exploit_generator_initialized")
    except ValueError as e:
        logger.error("exploit_generator_init_failed", error=str(e))
        raise
    
    yield
    
    logger.info("exploit_generator_shutdown")


app = FastAPI(
    title="Exploit Generator",
    description="LLM-powered exploit PoC generation and validation",
    version="1.0.0",
    lifespan=lifespan,
)


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy"}


@app.get("/ready")
async def ready():
    """Readiness check endpoint."""
    if generator is None:
        raise HTTPException(status_code=503, detail="Generator not initialized")
    return {"status": "ready"}


@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint."""
    return Response(
        content=generate_latest(),
        media_type=CONTENT_TYPE_LATEST
    )


@app.post("/")
async def handle_event(request: Request):
    """
    Handle incoming CloudEvents.
    
    Accepts:
    - io.homelab.vuln.found: Vulnerability to generate exploit for
    
    Uses the same shared business logic as API endpoint for consistency and tracing.
    """
    import time
    start_time = time.monotonic()
    
    tracer = trace.get_tracer(__name__)
    
    # Parse CloudEvent
    try:
        event = from_http(dict(request.headers), await request.body())
    except Exception as e:
        logger.error("cloudevent_parse_failed", error=str(e))
        raise HTTPException(status_code=400, detail=f"Invalid CloudEvent: {e}")
    
    event_type = event["type"]
    event_id = event.get("id", "unknown")
    event_source = event.get("source", "unknown")
    
    # Create tracing span for CloudEvent processing
    with tracer.start_as_current_span(
        f"cloudevent.{event_type.replace('.', '_').replace(':', '_')}",
        attributes={
            "cloudevent.type": event_type,
            "cloudevent.source": event_source,
            "cloudevent.id": event_id,
        }
    ) as span:
        log = logger.bind(
            event_type=event_type,
            event_id=event_id,
        )
        log.info("event_received", source_type="cloudevent")
        
        if event_type != "io.homelab.vuln.found":
            log.warning("unknown_event_type")
            span.set_attribute("cloudevent.error", "unknown_event_type")
            span.set_attribute("cloudevent.duration_ms", (time.monotonic() - start_time) * 1000)
            return JSONResponse(
                status_code=200,
                content={"status": "ignored", "reason": "Unknown event type"}
            )
        
        # Use shared business logic (same as API endpoint)
        result = await handle_exploit_generation(event, span)
        
        span.set_attribute("cloudevent.duration_ms", (time.monotonic() - start_time) * 1000)
        return result


async def handle_exploit_generation(event: CloudEvent, span=None) -> Response:
    """
    Handle exploit generation request.
    
    Shared business logic used by both API endpoint and CloudEvent handler.
    """
    data = event.data
    chain = data.get("chain", "ethereum")
    address = data.get("address")
    vulnerabilities = data.get("vulnerabilities", [])
    source_code = data.get("source_code", "")
    abi = data.get("abi")
    
    if span:
        span.set_attribute("contract.chain", chain)
        span.set_attribute("contract.address", address or "unknown")
        span.set_attribute("vulnerabilities.count", len(vulnerabilities))
    
    if not address:
        if span:
            span.set_attribute("cloudevent.error", "missing_address")
        raise HTTPException(status_code=400, detail="Missing 'address' in event data")
    
    if not vulnerabilities:
        if span:
            span.set_attribute("generation.skipped", True)
            span.set_attribute("generation.reason", "no_vulnerabilities")
        return JSONResponse(
            status_code=200,
            content={"status": "skipped", "reason": "No vulnerabilities to exploit"}
        )
    
    # Filter for high+ severity only
    severity_threshold = os.getenv("EXPLOIT_SEVERITY_THRESHOLD", "high")
    high_vulns = [
        v for v in vulnerabilities
        if v.get("severity") in ["critical", "high"]
        or (severity_threshold == "medium" and v.get("severity") == "medium")
    ]
    
    if span:
        span.set_attribute("vulnerabilities.high_severity_count", len(high_vulns))
    
    if not high_vulns:
        if span:
            span.set_attribute("generation.skipped", True)
            span.set_attribute("generation.reason", "no_high_severity")
        return JSONResponse(
            status_code=200,
            content={"status": "skipped", "reason": "No high+ severity vulnerabilities"}
        )
    
    log = logger.bind(chain=chain, address=address, num_vulns=len(high_vulns))
    log.info("generating_exploits")
    
    results = []
    for vuln in high_vulns[:3]:  # Limit to 3 exploits per contract
        try:
            # Use shared business logic (same as API endpoint)
            result = await generator.generate(
                chain=chain,
                contract_address=address,
                source_code=source_code,
                vulnerability=vuln,
                abi=abi,
            )
            results.append(result)
            
            if span:
                span.set_attribute(f"exploit.{len(results)}.status", result.status.value)
                span.set_attribute(f"exploit.{len(results)}.vuln_type", vuln.get("type", "unknown"))
            
            # Send events for validated exploits
            if result.status == ExploitStatus.VALIDATED:
                k_sink = os.getenv("K_SINK")
                if k_sink:
                    import httpx
                    async with httpx.AsyncClient() as client:
                        # Send exploit.validated event
                        exploit_event = create_exploit_validated_event(result)
                        headers, body = to_structured(exploit_event)
                        await client.post(k_sink, headers=headers, content=body)
                        
                        # Send alert for critical
                        if vuln.get("severity") == "critical":
                            alert_event = create_alert_sent_event(result, "critical")
                            headers, body = to_structured(alert_event)
                            await client.post(k_sink, headers=headers, content=body)
                        
                        log.info("events_sent_to_sink", sink=k_sink)
                        if span:
                            span.set_attribute("cloudevent.sent_to_sink", True)
                            span.set_attribute("cloudevent.sink", k_sink)
                        
        except Exception as e:
            log.error("exploit_generation_failed", vuln_type=vuln.get("type"), error=str(e))
            if span:
                span.set_attribute("cloudevent.error", str(e))
    
    validated_count = sum(1 for r in results if r.status == ExploitStatus.VALIDATED)
    if span:
        span.set_attribute("exploits.generated", len(results))
        span.set_attribute("exploits.validated", validated_count)
    
    return JSONResponse(content={
        "chain": chain,
        "address": address,
        "results": [r.to_dict() for r in results],
        "validated_count": validated_count,
    })


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)

