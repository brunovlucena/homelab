"""
Unit tests for Exploit Generator.
"""
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
import os

import sys
sys.path.insert(0, str(__file__).replace("/tests/unit/test_exploit_generator.py", "/src"))

from exploit_generator.handler import (
    ExploitGenerator,
    ExploitResult,
    ExploitStatus,
    ALLOWED_RPC_ENDPOINTS,
    create_exploit_validated_event,
    create_alert_sent_event,
)


class TestExploitResult:
    """Tests for ExploitResult dataclass."""
    
    def test_to_dict(self):
        """Test serialization to dict."""
        result = ExploitResult(
            chain="ethereum",
            contract_address="0x1234",
            vulnerability_type="reentrancy",
            exploit_code="contract Exploit {}",
            status=ExploitStatus.VALIDATED,
            profit_potential="1.5 ETH",
        )
        
        d = result.to_dict()
        assert d["chain"] == "ethereum"
        assert d["status"] == "validated"
        assert d["profit_potential"] == "1.5 ETH"


class TestExploitGeneratorSafety:
    """Safety tests for ExploitGenerator."""
    
    def test_only_allowed_rpc_endpoints(self):
        """Test that only Anvil endpoints are allowed."""
        # Should work with allowed endpoint
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        assert gen.anvil_url == "http://localhost:8545"
        
        # Should raise for mainnet
        with pytest.raises(ValueError, match="not in allowed list"):
            ExploitGenerator(anvil_url="https://mainnet.infura.io/v3/key")
    
    def test_allowed_endpoints_list(self):
        """Test the allowed endpoints list."""
        # These should be local/Anvil only
        for endpoint in ALLOWED_RPC_ENDPOINTS:
            assert "mainnet" not in endpoint.lower()
            assert "infura" not in endpoint.lower()
            assert "alchemy" not in endpoint.lower()
            # Should be localhost or anvil
            assert any(x in endpoint for x in ["localhost", "127.0.0.1", "anvil"])


class TestExploitGenerator:
    """Tests for ExploitGenerator class."""
    
    def test_extract_solidity_from_code_block(self):
        """Test extracting Solidity from markdown code block."""
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        
        response = '''
Here's the exploit:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Exploit {
    function attack() external {}
}
```

This exploits the vulnerability.
'''
        
        code = gen._extract_solidity(response)
        assert code is not None
        assert "pragma solidity" in code
        assert "contract Exploit" in code
    
    def test_extract_solidity_from_generic_block(self):
        """Test extracting Solidity from generic code block."""
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        
        response = '''
```
pragma solidity ^0.8.0;
contract Test {}
```
'''
        
        code = gen._extract_solidity(response)
        assert code is not None
        assert "pragma solidity" in code
    
    def test_extract_solidity_no_block(self):
        """Test extracting Solidity when no code block."""
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        
        response = '''
pragma solidity ^0.8.0;
contract Direct {}
'''
        
        code = gen._extract_solidity(response)
        assert code is not None
        assert "pragma solidity" in code
    
    def test_extract_solidity_no_code(self):
        """Test when no Solidity code present."""
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        
        response = "I cannot generate an exploit for this."
        
        code = gen._extract_solidity(response)
        assert code is None
    
    def test_build_prompt(self, sample_contract_source, sample_vulnerability):
        """Test exploit generation prompt."""
        gen = ExploitGenerator(anvil_url="http://localhost:8545")
        
        prompt = gen._build_prompt(
            sample_contract_source,
            sample_vulnerability,
            "0x1234",
            None,
        )
        
        assert "security researcher" in prompt.lower()
        assert "0x1234" in prompt
        assert "reentrancy" in prompt.lower()
        assert "Foundry" in prompt


class TestCloudEventCreation:
    """Tests for CloudEvent creation."""
    
    def test_create_exploit_validated_event(self):
        """Test creating exploit.validated CloudEvent."""
        result = ExploitResult(
            chain="ethereum",
            contract_address="0x1234",
            vulnerability_type="reentrancy",
            exploit_code="contract Exploit {}",
            status=ExploitStatus.VALIDATED,
            profit_potential="1.5 ETH",
        )
        
        event = create_exploit_validated_event(result)
        
        assert event["type"] == "io.homelab.exploit.validated"
        assert event["source"] == "/agent-contracts/exploit-generator"
        assert "ethereum" in event["subject"]
    
    def test_create_alert_sent_event(self):
        """Test creating alert CloudEvent for exploit."""
        result = ExploitResult(
            chain="ethereum",
            contract_address="0x1234",
            vulnerability_type="reentrancy",
            status=ExploitStatus.VALIDATED,
        )
        
        event = create_alert_sent_event(result, "critical")
        
        assert event["type"] == "io.homelab.alert.sent"
        assert event.data["severity"] == "critical"
        assert "Validated Exploit" in event.data["title"]

