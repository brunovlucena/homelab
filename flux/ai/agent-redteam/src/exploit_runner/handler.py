"""
Exploit runner handler for agent-redteam.

Executes security exploits against Knative Lambda Operator to validate
vulnerability mitigations and security controls.

⚠️ WARNING: This agent is for AUTHORIZED TESTING ONLY.
Only run against test clusters you own or have explicit permission to test.
"""
import os
import asyncio
import time
import tempfile
import random
from pathlib import Path
from typing import Optional
from uuid import uuid4

import structlog
import yaml
from kubernetes import client, config
from kubernetes.client.rest import ApiException

from shared.types import (
    ExploitDefinition,
    ExploitResult,
    ExploitStatus,
    ExploitSeverity,
    ExploitCategory,
    TargetComponent,
    ExploitCatalog,
    TestRun,
)
from shared.metrics import (
    EXPLOITS_EXECUTED,
    EXPLOITS_SUCCESSFUL,
    EXPLOITS_BLOCKED,
    ACTIVE_EXPLOITS,
    EXPLOIT_DURATION,
    TEST_RUNS_TOTAL,
    TEST_RUNS_ACTIVE,
    VULNERABILITIES_FOUND,
    TEST_RUN_DURATION,
    K8S_OPERATIONS,
    K8S_OPERATION_DURATION,
    init_catalog_info,
)

logger = structlog.get_logger()

# =============================================================================
# Built-in Exploit Catalog
# =============================================================================

BUILTIN_EXPLOITS = [
    ExploitDefinition(
        id="blue-001",
        name="SSRF via Go-Git Library",
        description="Exploits go-git library to make SSRF requests to internal services like AWS metadata, K8s API",
        severity=ExploitSeverity.CRITICAL,
        category=ExploitCategory.SSRF,
        target_component=TargetComponent.GIT_CLONE,
        manifest_path="exploits/blue-001-ssrf-git/",
        expected_outcome="Access to internal services (169.254.169.254, kubernetes.default)",
        detection_signature="spec.source.git.url contains metadata or kubernetes.default",
        tags=["ssrf", "aws", "kubernetes", "git"],
    ),
    ExploitDefinition(
        id="blue-002",
        name="Go Template Injection",
        description="Inject Go template code via handler field for RCE",
        severity=ExploitSeverity.CRITICAL,
        category=ExploitCategory.TEMPLATE_INJECTION,
        target_component=TargetComponent.LAMBDA_OPERATOR,
        manifest_path="exploits/blue-002-template-injection/",
        expected_outcome="Remote code execution via template injection",
        detection_signature="spec.runtime.handler contains {{ or }}",
        tags=["rce", "template", "injection"],
    ),
    ExploitDefinition(
        id="blue-005",
        name="Path Traversal via Git",
        description="Use git path traversal to read arbitrary files from build pod",
        severity=ExploitSeverity.HIGH,
        category=ExploitCategory.PATH_TRAVERSAL,
        target_component=TargetComponent.GIT_CLONE,
        manifest_path="exploits/blue-005-path-traversal/",
        expected_outcome="Read /etc/passwd, SA tokens, or other sensitive files",
        detection_signature="git operations with ../ patterns",
        tags=["path-traversal", "file-read", "git"],
    ),
    ExploitDefinition(
        id="blue-006",
        name="Service Account Token Exposure",
        description="Steal service account token from build job pod",
        severity=ExploitSeverity.HIGH,
        category=ExploitCategory.TOKEN_EXPOSURE,
        target_component=TargetComponent.SERVICE_ACCOUNT,
        manifest_path="exploits/blue-006-sa-token-exposure/",
        expected_outcome="Exfiltrate kubernetes SA token for privilege escalation",
        detection_signature="Access to /var/run/secrets/kubernetes.io/serviceaccount/token",
        tags=["token", "service-account", "privilege-escalation"],
    ),
    ExploitDefinition(
        id="vuln-001",
        name="Command Injection via Git URL/Ref",
        description="Inject shell commands via git URL or ref fields",
        severity=ExploitSeverity.CRITICAL,
        category=ExploitCategory.COMMAND_INJECTION,
        target_component=TargetComponent.GIT_CLONE,
        manifest_path="exploits/vuln-001-cmd-injection-git/",
        expected_outcome="Shell command execution in build pod init container",
        detection_signature="git URL contains ; | ` $( or backticks",
        tags=["rce", "command-injection", "git", "shell"],
    ),
    ExploitDefinition(
        id="vuln-002",
        name="Command Injection via MinIO Fields",
        description="Inject shell commands via MinIO bucket/key/endpoint fields",
        severity=ExploitSeverity.CRITICAL,
        category=ExploitCategory.COMMAND_INJECTION,
        target_component=TargetComponent.MINIO,
        manifest_path="exploits/vuln-002-cmd-injection-minio/",
        expected_outcome="Shell command execution via MinIO operations",
        detection_signature="MinIO fields contain shell metacharacters",
        tags=["rce", "command-injection", "minio", "shell"],
    ),
    ExploitDefinition(
        id="vuln-003",
        name="Arbitrary Inline Code Execution",
        description="Execute arbitrary Python/Node.js code via inline source",
        severity=ExploitSeverity.CRITICAL,
        category=ExploitCategory.CODE_INJECTION,
        target_component=TargetComponent.LAMBDA_OPERATOR,
        manifest_path="exploits/vuln-003-inline-code-exec/",
        expected_outcome="Arbitrary code execution in function container",
        detection_signature="inline source contains os.system, subprocess, exec, eval",
        tags=["rce", "code-injection", "inline", "python", "nodejs"],
    ),
    ExploitDefinition(
        id="vuln-004",
        name="RBAC Privilege Escalation",
        description="Exploit overly permissive RBAC to create cluster-admin",
        severity=ExploitSeverity.HIGH,
        category=ExploitCategory.RBAC_ESCALATION,
        target_component=TargetComponent.KUBERNETES_API,
        manifest_path="exploits/vuln-004-rbac-escalation/",
        expected_outcome="Create cluster-admin ClusterRoleBinding",
        detection_signature="Unauthorized clusterrole/clusterrolebinding creation",
        tags=["rbac", "privilege-escalation", "cluster-admin"],
    ),
    ExploitDefinition(
        id="vuln-013",
        name="Receiver Mode SA Escalation",
        description="Inherit service account permissions via receiver mode",
        severity=ExploitSeverity.MEDIUM,
        category=ExploitCategory.RECEIVER_ESCALATION,
        target_component=TargetComponent.SERVICE_ACCOUNT,
        manifest_path="exploits/vuln-013-receiver-escalation/",
        expected_outcome="Use inherited SA token for unauthorized access",
        detection_signature="Receiver mode function with elevated SA",
        tags=["receiver", "service-account", "privilege-escalation"],
    ),
]


class KubernetesClient:
    """Kubernetes API client for exploit execution (uses K8s API, not kubectl CLI)."""
    
    def __init__(self, kubeconfig: Optional[str] = None, context: Optional[str] = None):
        self.kubeconfig = kubeconfig or os.getenv("KUBECONFIG")
        self.context = context or os.getenv("K8S_CONTEXT")
        self.timeout = int(os.getenv("K8S_TIMEOUT", "60"))
        
        # Load K8s config
        try:
            if os.path.exists("/var/run/secrets/kubernetes.io/serviceaccount/token"):
                # In-cluster config
                config.load_incluster_config()
                logger.info("k8s_client_initialized", mode="in-cluster")
            elif self.kubeconfig:
                # Kubeconfig file
                config.load_kube_config(config_file=self.kubeconfig, context=self.context)
                logger.info("k8s_client_initialized", mode="kubeconfig", config=self.kubeconfig)
            else:
                # Default kubeconfig
                config.load_kube_config(context=self.context)
                logger.info("k8s_client_initialized", mode="default")
        except Exception as e:
            logger.error("k8s_client_init_failed", error=str(e))
            raise
        
        # Initialize API clients
        self.core_v1 = client.CoreV1Api()
        self.custom_api = client.CustomObjectsApi()
        self.batch_v1 = client.BatchV1Api()
    
    async def apply_manifest(self, manifest: str, namespace: str) -> tuple[bool, str]:
        """Apply a Kubernetes manifest using K8s API."""
        start = time.monotonic()
        
        try:
            # Parse YAML manifest
            docs = yaml.safe_load_all(manifest)
            results = []
            
            for doc in docs:
                if not doc:
                    continue
                
                api_version = doc.get("apiVersion", "")
                kind = doc.get("kind", "")
                metadata = doc.get("metadata", {})
                name = metadata.get("name", "")
                
                if not name:
                    continue
                
                # Handle LambdaFunction CRD
                if api_version == "lambda.knative.io/v1alpha1" and kind == "LambdaFunction":
                    # Use CustomObjectsApi for CRDs
                    group = "lambda.knative.io"
                    version = "v1alpha1"
                    plural = "lambdafunctions"
                    
                    try:
                        # Try to get existing resource
                        existing = self.custom_api.get_namespaced_custom_object(
                            group=group,
                            version=version,
                            namespace=namespace,
                            plural=plural,
                            name=name,
                        )
                        # Update existing
                        result = self.custom_api.patch_namespaced_custom_object(
                            group=group,
                            version=version,
                            namespace=namespace,
                            plural=plural,
                            name=name,
                            body=doc,
                        )
                        results.append(f"{kind}/{name} patched")
                    except ApiException as e:
                        if e.status == 404:
                            # Create new resource
                            result = self.custom_api.create_namespaced_custom_object(
                                group=group,
                                version=version,
                                namespace=namespace,
                                plural=plural,
                                body=doc,
                            )
                            results.append(f"{kind}/{name} created")
                        else:
                            raise
                else:
                    # Handle standard K8s resources
                    # This is simplified - would need proper API group detection
                    results.append(f"{kind}/{name} - standard resource (not implemented)")
            
            duration = time.monotonic() - start
            K8S_OPERATION_DURATION.labels(operation="apply", resource="manifest").observe(duration)
            K8S_OPERATIONS.labels(operation="apply", resource="manifest", status="success").inc()
            
            return True, "\n".join(results)
            
        except ApiException as e:
            duration = time.monotonic() - start
            K8S_OPERATION_DURATION.labels(operation="apply", resource="manifest").observe(duration)
            K8S_OPERATIONS.labels(operation="apply", resource="manifest", status="error").inc()
            error_msg = f"K8s API error: {e.status} - {e.reason}: {e.body}"
            logger.error("k8s_apply_failed", error=error_msg)
            return False, error_msg
        except Exception as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="apply", resource="manifest", status="error").inc()
            error_msg = f"Error applying manifest: {str(e)}"
            logger.error("k8s_apply_failed", error=error_msg)
            return False, error_msg
    
    async def delete_resource(self, resource_type: str, name: str, namespace: str) -> tuple[bool, str]:
        """Delete a Kubernetes resource using K8s API."""
        start = time.monotonic()
        
        try:
            # Handle LambdaFunction CRD
            if resource_type.lower() in ["lambdafunction", "lambdafunctions"]:
                group = "lambda.knative.io"
                version = "v1alpha1"
                plural = "lambdafunctions"
                
                try:
                    self.custom_api.delete_namespaced_custom_object(
                        group=group,
                        version=version,
                        namespace=namespace,
                        plural=plural,
                        name=name,
                    )
                    duration = time.monotonic() - start
                    K8S_OPERATION_DURATION.labels(operation="delete", resource=resource_type).observe(duration)
                    K8S_OPERATIONS.labels(operation="delete", resource=resource_type, status="success").inc()
                    return True, f"LambdaFunction {name} deleted"
                except ApiException as e:
                    if e.status == 404:
                        # Already deleted
                        return True, f"LambdaFunction {name} not found (already deleted)"
                    raise
            else:
                # Standard resources - simplified
                return False, f"Delete for {resource_type} not implemented via API"
                
        except ApiException as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="delete", resource=resource_type, status="error").inc()
            error_msg = f"K8s API error: {e.status} - {e.reason}"
            return False, error_msg
        except Exception as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="delete", resource=resource_type, status="error").inc()
            return False, f"Error deleting resource: {str(e)}"
    
    async def get_resource(self, resource_type: str, name: str, namespace: str) -> tuple[bool, dict]:
        """Get a Kubernetes resource using K8s API."""
        start = time.monotonic()
        
        try:
            # Handle LambdaFunction CRD
            if resource_type.lower() in ["lambdafunction", "lambdafunctions"]:
                group = "lambda.knative.io"
                version = "v1alpha1"
                plural = "lambdafunctions"
                
                result = self.custom_api.get_namespaced_custom_object(
                    group=group,
                    version=version,
                    namespace=namespace,
                    plural=plural,
                    name=name,
                )
                
                duration = time.monotonic() - start
                K8S_OPERATION_DURATION.labels(operation="get", resource=resource_type).observe(duration)
                K8S_OPERATIONS.labels(operation="get", resource=resource_type, status="success").inc()
                return True, result
            else:
                return False, {"error": f"Get for {resource_type} not implemented via API"}
                
        except ApiException as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="get", resource=resource_type, status="error").inc()
            if e.status == 404:
                return False, {"error": "Resource not found"}
            return False, {"error": f"K8s API error: {e.status} - {e.reason}"}
        except Exception as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="get", resource=resource_type, status="error").inc()
            return False, {"error": str(e)}
    
    async def get_logs(self, pod_name: str, namespace: str, container: Optional[str] = None) -> tuple[bool, str]:
        """Get logs from a pod using K8s API."""
        try:
            logs = self.core_v1.read_namespaced_pod_log(
                name=pod_name,
                namespace=namespace,
                container=container,
                tail_lines=100,
            )
            return True, logs
        except ApiException as e:
            return False, f"K8s API error: {e.status} - {e.reason}"
        except Exception as e:
            return False, f"Error getting logs: {str(e)}"
    
    async def create_testrun(
        self,
        name: str,
        namespace: str,
        test_type: str,
        script_configmap: str,
        script_file: str = "script.js",
        env_vars: Optional[dict] = None,
        resources: Optional[dict] = None,
    ) -> tuple[bool, str]:
        """
        Create a k6 TestRun CRD using K8s API.
        
        Args:
            name: TestRun name
            namespace: Namespace for the TestRun
            test_type: Type of test (smoke, attack-sequential, attack-parallel, etc.)
            script_configmap: ConfigMap name containing the k6 script
            script_file: Script file name in ConfigMap (default: script.js)
            env_vars: Optional environment variables dict
            resources: Optional resource limits/requests dict
        
        Returns:
            Tuple of (success, message_or_error)
        """
        start = time.monotonic()
        
        try:
            group = "k6.io"
            version = "v1alpha1"
            plural = "testruns"
            
            # Build TestRun spec
            testrun_body = {
                "apiVersion": f"{group}/{version}",
                "kind": "TestRun",
                "metadata": {
                    "name": name,
                    "namespace": namespace,
                    "labels": {
                        "app.kubernetes.io/name": "agent-redteam",
                        "app.kubernetes.io/component": "testing",
                        "test-type": test_type,
                    },
                },
                "spec": {
                    "parallelism": 1,
                    "arguments": "-o experimental-prometheus-rw",
                    "script": {
                        "configMap": {
                            "name": script_configmap,
                            "file": script_file,
                        },
                    },
                    "runner": {
                        "image": "localhost:5001/k6:0.47.0",
                        "env": [
                            {
                                "name": "TARGET_URL",
                                "value": f"http://agent-redteam.{namespace}.svc.cluster.local",
                            },
                            {
                                "name": "TARGET_NAMESPACE",
                                "value": "redteam-test",
                            },
                            {
                                "name": "K6_PROMETHEUS_RW_SERVER_URL",
                                "value": "http://kube-prometheus-stack-prometheus.prometheus.svc.cluster.local:9090/api/v1/write",
                            },
                            {
                                "name": "K6_PROMETHEUS_RW_TREND_AS_NATIVE_HISTOGRAM",
                                "value": "true",
                            },
                        ],
                        "resources": {
                            "limits": {
                                "memory": "512Mi",
                                "cpu": "500m",
                            },
                        },
                    },
                },
            }
            
            # Add custom env vars if provided
            if env_vars:
                for key, value in env_vars.items():
                    testrun_body["spec"]["runner"]["env"].append({
                        "name": key,
                        "value": str(value),
                    })
            
            # Override resources if provided
            if resources:
                testrun_body["spec"]["runner"]["resources"] = resources
            
            # Create TestRun
            result = self.custom_api.create_namespaced_custom_object(
                group=group,
                version=version,
                namespace=namespace,
                plural=plural,
                body=testrun_body,
            )
            
            duration = time.monotonic() - start
            K8S_OPERATION_DURATION.labels(operation="create", resource="testrun").observe(duration)
            K8S_OPERATIONS.labels(operation="create", resource="testrun", status="success").inc()
            
            return True, f"TestRun {name} created successfully"
            
        except ApiException as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="create", resource="testrun", status="error").inc()
            error_msg = f"K8s API error creating TestRun: {e.status} - {e.reason}: {e.body}"
            logger.error("k8s_testrun_create_failed", error=error_msg)
            return False, error_msg
        except Exception as e:
            duration = time.monotonic() - start
            K8S_OPERATIONS.labels(operation="create", resource="testrun", status="error").inc()
            error_msg = f"Error creating TestRun: {str(e)}"
            logger.error("k8s_testrun_create_failed", error=error_msg)
            return False, error_msg
    
    async def get_testrun(self, name: str, namespace: str) -> tuple[bool, dict]:
        """Get a TestRun CRD."""
        try:
            group = "k6.io"
            version = "v1alpha1"
            plural = "testruns"
            
            result = self.custom_api.get_namespaced_custom_object(
                group=group,
                version=version,
                namespace=namespace,
                plural=plural,
                name=name,
            )
            
            return True, result
        except ApiException as e:
            if e.status == 404:
                return False, {"error": "TestRun not found"}
            return False, {"error": f"K8s API error: {e.status} - {e.reason}"}
        except Exception as e:
            return False, {"error": str(e)}


class ExploitRunner:
    """
    Main exploit runner orchestrating security tests.
    
    ⚠️ WARNING: Only use against authorized test environments.
    """
    
    def __init__(
        self,
        exploits_base_path: Optional[str] = None,
        k8s_client: Optional[KubernetesClient] = None,
    ):
        self.exploits_base_path = Path(exploits_base_path or os.getenv(
            "EXPLOITS_PATH",
            "/app/exploits"
        ))
        self.k8s = k8s_client or KubernetesClient()
        self.catalog = self._build_catalog()
        self.target_namespace = os.getenv("TARGET_NAMESPACE", "redteam-test")
        self.dry_run = os.getenv("DRY_RUN", "false").lower() == "true"
        
        # Initialize catalog metrics
        init_catalog_info(
            catalog_version=self.catalog.version,
            exploit_count=len(self.catalog.exploits)
        )
        
        logger.info(
            "exploit_runner_initialized",
            exploits_path=str(self.exploits_base_path),
            catalog_size=len(self.catalog.exploits),
            dry_run=self.dry_run,
        )
    
    def _build_catalog(self) -> ExploitCatalog:
        """Build exploit catalog from built-in definitions."""
        return ExploitCatalog(
            exploits=BUILTIN_EXPLOITS,
            version="1.0.0"
        )
    
    def get_catalog(self) -> ExploitCatalog:
        """Return the exploit catalog."""
        return self.catalog
    
    async def run_exploit(
        self,
        exploit_id: str,
        manifest_name: Optional[str] = None,
        namespace: Optional[str] = None,
    ) -> ExploitResult:
        """
        Run a single exploit.
        
        Args:
            exploit_id: ID of the exploit to run (e.g., "vuln-001")
            manifest_name: Specific manifest file to run (optional)
            namespace: Target namespace (optional, uses default)
            
        Returns:
            ExploitResult with execution status
        """
        log = logger.bind(exploit_id=exploit_id)
        namespace = namespace or self.target_namespace
        
        # Find exploit definition
        exploit_def = self.catalog.get_by_id(exploit_id)
        if not exploit_def:
            log.error("exploit_not_found")
            return ExploitResult(
                exploit_id=exploit_id,
                status=ExploitStatus.ERROR,
                error=f"Exploit '{exploit_id}' not found in catalog",
            )
        
        log = log.bind(
            exploit_name=exploit_def.name,
            category=exploit_def.category.value,
            severity=exploit_def.severity.value,
        )
        
        result = ExploitResult(
            exploit_id=exploit_id,
            status=ExploitStatus.RUNNING,
        )
        
        ACTIVE_EXPLOITS.inc()
        start_time = time.monotonic()
        
        try:
            log.info("exploit_starting", dry_run=self.dry_run)
            
            # Load exploit manifest(s)
            manifest_dir = self.exploits_base_path / exploit_def.manifest_path
            if not manifest_dir.exists():
                log.warning("exploit_manifests_not_found", path=str(manifest_dir))
                # Use embedded manifest for demo
                manifest_content = self._get_demo_manifest(exploit_def)
            else:
                # Load specific manifest or all manifests
                if manifest_name:
                    manifest_file = manifest_dir / manifest_name
                    manifest_content = manifest_file.read_text() if manifest_file.exists() else ""
                else:
                    # Load first YAML file
                    yaml_files = list(manifest_dir.glob("*.yaml"))
                    if yaml_files:
                        manifest_content = yaml_files[0].read_text()
                    else:
                        manifest_content = ""
            
            if not manifest_content:
                result.status = ExploitStatus.ERROR
                result.error = "No manifest found for exploit"
                return result
            
            # Dry run - just validate and return
            if self.dry_run:
                log.info("exploit_dry_run")
                result.status = ExploitStatus.SUCCESS
                result.output = f"[DRY RUN] Would apply manifest for {exploit_def.name}"
                return result
            
            # Apply the exploit manifest
            success, output = await self.k8s.apply_manifest(manifest_content, namespace)
            
            if not success:
                # Check if it was blocked by admission webhook
                if "denied" in output.lower() or "admission" in output.lower():
                    result.status = ExploitStatus.BLOCKED
                    result.mitigated_by = "admission_webhook"
                    result.output = output
                    log.info("exploit_blocked", mitigated_by="admission_webhook")
                    
                    EXPLOITS_BLOCKED.labels(
                        exploit_id=exploit_id,
                        category=exploit_def.category.value,
                        severity=exploit_def.severity.value,
                        mitigated_by="admission_webhook",
                    ).inc()
                else:
                    result.status = ExploitStatus.FAILED
                    result.error = output
                    log.warning("exploit_failed", error=output)
            else:
                # Manifest applied - wait and check for success indicators
                result.output = output
                
                # Wait for resource to be processed
                await asyncio.sleep(5)
                
                # Check if the exploit succeeded (this is simplified - real impl would check more)
                validation_result = await self._validate_exploit_success(exploit_def, namespace)
                
                if validation_result["success"]:
                    result.status = ExploitStatus.SUCCESS
                    result.artifacts = validation_result.get("artifacts", [])
                    log.warning("exploit_successful", artifacts=result.artifacts)
                    
                    EXPLOITS_SUCCESSFUL.labels(
                        exploit_id=exploit_id,
                        category=exploit_def.category.value,
                        severity=exploit_def.severity.value,
                    ).inc()
                elif validation_result.get("blocked"):
                    result.status = ExploitStatus.BLOCKED
                    result.mitigated_by = validation_result.get("mitigated_by", "unknown")
                    log.info("exploit_blocked_runtime", mitigated_by=result.mitigated_by)
                    
                    EXPLOITS_BLOCKED.labels(
                        exploit_id=exploit_id,
                        category=exploit_def.category.value,
                        severity=exploit_def.severity.value,
                        mitigated_by=result.mitigated_by,
                    ).inc()
                else:
                    result.status = ExploitStatus.FAILED
                    result.error = validation_result.get("error", "Unknown failure")
            
        except Exception as e:
            result.status = ExploitStatus.ERROR
            result.error = str(e)
            log.error("exploit_error", error=str(e))
        finally:
            # Record duration and metrics
            duration = time.monotonic() - start_time
            result.duration_seconds = duration
            result.completed_at = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
            
            ACTIVE_EXPLOITS.dec()
            EXPLOIT_DURATION.labels(
                exploit_id=exploit_id,
                category=exploit_def.category.value,
            ).observe(duration)
            
            EXPLOITS_EXECUTED.labels(
                exploit_id=exploit_id,
                category=exploit_def.category.value,
                severity=exploit_def.severity.value,
                status=result.status.value,
            ).inc()
            
            log.info(
                "exploit_completed",
                status=result.status.value,
                duration_seconds=duration,
            )
        
        return result
    
    async def run_test(
        self,
        name: str,
        exploit_ids: Optional[list[str]] = None,
        categories: Optional[list[ExploitCategory]] = None,
        severities: Optional[list[ExploitSeverity]] = None,
        namespace: Optional[str] = None,
    ) -> TestRun:
        """
        Run a test suite of multiple exploits.
        
        Args:
            name: Name for this test run
            exploit_ids: Specific exploits to run (optional)
            categories: Run all exploits in these categories (optional)
            severities: Run all exploits of these severities (optional)
            namespace: Target namespace
            
        Returns:
            TestRun with all results
        """
        log = logger.bind(test_name=name)
        namespace = namespace or self.target_namespace
        
        # Build list of exploits to run
        exploits_to_run: list[ExploitDefinition] = []
        
        if exploit_ids:
            for eid in exploit_ids:
                exploit = self.catalog.get_by_id(eid)
                if exploit:
                    exploits_to_run.append(exploit)
        elif categories:
            for cat in categories:
                exploits_to_run.extend(self.catalog.get_by_category(cat))
        elif severities:
            for sev in severities:
                exploits_to_run.extend(self.catalog.get_by_severity(sev))
        else:
            # Run all
            exploits_to_run = self.catalog.exploits
        
        # Remove duplicates while preserving order
        seen = set()
        unique_exploits = []
        for e in exploits_to_run:
            if e.id not in seen:
                seen.add(e.id)
                unique_exploits.append(e)
        
        test_run = TestRun(
            id=str(uuid4()),
            name=name,
            target_cluster=self.k8s.context or "default",
            target_namespace=namespace,
            status="running",
        )
        
        TEST_RUNS_ACTIVE.inc()
        start_time = time.monotonic()
        
        log.info(
            "test_run_starting",
            test_id=test_run.id,
            exploit_count=len(unique_exploits),
        )
        
        try:
            # Run exploits sequentially
            for exploit in unique_exploits:
                result = await self.run_exploit(exploit.id, namespace=namespace)
                test_run.results.append(result)
                
                # Small delay between exploits
                await asyncio.sleep(1)
            
            test_run.status = "completed"
            TEST_RUNS_TOTAL.labels(status="completed").inc()
            
        except Exception as e:
            test_run.status = "failed"
            TEST_RUNS_TOTAL.labels(status="failed").inc()
            log.error("test_run_failed", error=str(e))
        finally:
            duration = time.monotonic() - start_time
            test_run.completed_at = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
            
            TEST_RUNS_ACTIVE.dec()
            TEST_RUN_DURATION.observe(duration)
            
            # Update vulnerabilities found gauge
            VULNERABILITIES_FOUND.labels(target_namespace=namespace).set(
                test_run.successful_exploits
            )
            
            log.info(
                "test_run_completed",
                test_id=test_run.id,
                status=test_run.status,
                total=test_run.total_exploits,
                successful=test_run.successful_exploits,
                blocked=test_run.blocked_exploits,
                failed=test_run.failed_exploits,
                duration_seconds=duration,
            )
        
        return test_run
    
    async def create_k6_testrun(
        self,
        test_type: str,
        namespace: str = "agent-redteam",
        env_vars: Optional[dict] = None,
    ) -> tuple[bool, str]:
        """
        Create a k6 TestRun CRD based on test type.
        
        Args:
            test_type: Type of k6 test (smoke, attack-sequential, attack-parallel, 
                      vulnerability-assessment, random-chaos)
            namespace: Namespace for the TestRun
            env_vars: Optional additional environment variables
        
        Returns:
            Tuple of (success, message_or_error)
        """
        log = logger.bind(test_type=test_type, namespace=namespace)
        
        # Map test types to ConfigMap names
        test_configmaps = {
            "smoke": "agent-redteam-smoke-script",
            "attack-sequential": "agent-redteam-attack-sequential-script",
            "attack-parallel": "agent-redteam-attack-parallel-script",
            "vulnerability-assessment": "agent-redteam-vulnerability-assessment-script",
            "random-chaos": "agent-redteam-random-exploit-chaos-script",
        }
        
        if test_type not in test_configmaps:
            log.error("k6_test_type_invalid", test_type=test_type)
            return False, f"Invalid test type: {test_type}. Valid types: {', '.join(test_configmaps.keys())}"
        
        configmap_name = test_configmaps[test_type]
        testrun_name = f"agent-redteam-{test_type}-{int(time.time())}"
        
        log.info("k6_testrun_creating", testrun_name=testrun_name)
        
        # Determine resources based on test type
        resources = {
            "limits": {
                "memory": "512Mi",
                "cpu": "500m",
            },
        }
        
        if test_type == "attack-parallel":
            resources = {
                "limits": {
                    "memory": "1Gi",
                    "cpu": "1000m",
                },
            }
        elif test_type == "smoke":
            resources = {
                "limits": {
                    "memory": "256Mi",
                    "cpu": "200m",
                },
            }
        
        success, message = await self.k8s.create_testrun(
            name=testrun_name,
            namespace=namespace,
            test_type=test_type,
            script_configmap=configmap_name,
            script_file="script.js",
            env_vars=env_vars,
            resources=resources,
        )
        
        if success:
            log.info("k6_testrun_created", testrun_name=testrun_name)
        else:
            log.error("k6_testrun_create_failed", error=message)
        
        return success, message
    
    async def cleanup(self, namespace: Optional[str] = None) -> dict:
        """
        Clean up all exploit resources from namespace.
        
        Args:
            namespace: Namespace to clean (defaults to target_namespace)
            
        Returns:
            Cleanup status
        """
        namespace = namespace or self.target_namespace
        log = logger.bind(namespace=namespace)
        log.info("cleanup_starting")
        
        # Delete LambdaFunction resources with redteam label
        success, output = await self.k8s.delete_resource(
            "lambdafunction",
            "-l redteam=true",
            namespace
        )
        
        log.info("cleanup_completed", success=success, output=output)
        
        return {
            "namespace": namespace,
            "success": success,
            "output": output,
        }
    
    async def _validate_exploit_success(
        self,
        exploit_def: ExploitDefinition,
        namespace: str,
    ) -> dict:
        """
        Validate if an exploit was successful.
        
        This is a simplified implementation - real validation would
        check for specific indicators based on exploit type.
        """
        # For now, just check if the resource was created
        # Real impl would check logs, exfiltrated data, etc.
        
        return {
            "success": True,  # Assume success if resource was applied
            "blocked": False,
            "artifacts": [],
        }
    
    def _get_demo_manifest(self, exploit_def: ExploitDefinition) -> str:
        """Generate a demo manifest for testing when real manifests aren't available."""
        return f"""---
# Demo manifest for {exploit_def.id}: {exploit_def.name}
# ⚠️ This is a placeholder - use real exploits from redteam folder
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: {exploit_def.id.replace('_', '-')}-demo
  labels:
    redteam: "true"
    exploit: "{exploit_def.id}"
    severity: "{exploit_def.severity.value}"
  annotations:
    redteam.knative.io/description: "{exploit_def.description}"
spec:
  source:
    type: inline
    inline:
      content: |
        # Demo exploit - {exploit_def.name}
        def handler(event, context):
            return {{"exploit": "{exploit_def.id}", "status": "demo"}}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
"""
