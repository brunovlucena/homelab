# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
#  ðŸ”´ K6 RANDOM EXPLOIT CHAOS TEST - AGENT-REDTEAM
#
#  Purpose: Simulate chaotic attack scenario with random exploits
#  Scenario: Unpredictable attacker launching random exploits continuously
#            Tests system resilience under random attack patterns
#
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
---
apiVersion: k6.io/v1alpha1
kind: TestRun
metadata:
  name: agent-redteam-random-exploit-chaos
  namespace: agent-redteam
  labels:
    app.kubernetes.io/name: agent-redteam
    app.kubernetes.io/component: testing
    test-type: chaos
    attack-pattern: random
spec:
  parallelism: 1
  arguments: -o experimental-prometheus-rw
  script:
    configMap:
      name: agent-redteam-random-exploit-chaos-script
      file: script.js
  runner:
    image: localhost:5001/k6:0.47.0
    env:
      - name: TARGET_URL
        value: "http://agent-redteam.agent-redteam.svc.cluster.local"
      - name: TARGET_NAMESPACE
        value: "redteam-test"
      - name: K6_PROMETHEUS_RW_SERVER_URL
        value: "http://kube-prometheus-stack-prometheus.prometheus.svc.cluster.local:9090/api/v1/write"
      - name: K6_PROMETHEUS_RW_TREND_AS_NATIVE_HISTOGRAM
        value: "true"
    resources:
      limits:
        memory: 512Mi
        cpu: 500m

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-redteam-random-exploit-chaos-script
  namespace: agent-redteam
  labels:
    app.kubernetes.io/name: agent-redteam
    app.kubernetes.io/component: testing
    test-type: chaos
data:
  script.js: |
    import http from 'k6/http';
    import { check, group, sleep } from 'k6';
    import { Rate, Counter, Trend } from 'k6/metrics';
    
    // Custom Metrics
    const randomExploitExecuted = new Counter('chaos_random_exploit_executed');
    const randomExploitSuccess = new Rate('chaos_random_exploit_success');
    const randomExploitBlocked = new Rate('chaos_random_exploit_blocked');
    const chaosDuration = new Trend('chaos_exploit_duration_ms');
    const chaosIntensity = new Counter('chaos_intensity');
    
    // Configuration
    const BASE_URL = __ENV.TARGET_URL || 'http://agent-redteam.agent-redteam.svc.cluster.local';
    const TARGET_NAMESPACE = __ENV.TARGET_NAMESPACE || 'redteam-test';
    
    // All available exploits for random selection
    const ALL_EXPLOITS = [
      'vuln-001', 'vuln-002', 'vuln-003', 'vuln-004', 'vuln-013',
      'blue-001', 'blue-002', 'blue-005', 'blue-006',
    ];
    
    // Severity options for random filtering
    const SEVERITIES = ['critical', 'high', 'medium'];
    
    export const options = {
      scenarios: {
        random_chaos: {
          executor: 'ramping-arrival-rate',
          startRate: 0.5,
          stages: [
            { duration: '30s', target: 2 },   // Ramp up chaos
            { duration: '1m', target: 3 },    // Increase intensity
            { duration: '1m', target: 5 },    // Peak chaos
            { duration: '30s', target: 2 },   // Ramp down
            { duration: '30s', target: 0 },   // End
          ],
          preAllocatedVUs: 2,
          maxVUs: 10,
        },
      },
      thresholds: {
        'chaos_random_exploit_executed': ['count>=10'], // At least 10 random exploits
        'chaos_exploit_duration_ms': ['p(95)<60000'],
        'http_req_failed': ['rate<0.2'],
      },
    };
    
    export default function() {
      group('Random Exploit Chaos', () => {
        // Randomly decide: use specific exploit or random exploit endpoint
        const useRandomEndpoint = Math.random() > 0.5;
        
        let exploitRes;
        let exploitId = 'random';
        
        if (useRandomEndpoint) {
          // Use random exploit endpoint (simulates CloudEvent trigger)
          const randomSeverity = SEVERITIES[Math.floor(Math.random() * SEVERITIES.length)];
          
          exploitRes = http.post(
            `${BASE_URL}/exploit/run`,
            JSON.stringify({
              exploit_id: null, // Will trigger random selection
              namespace: TARGET_NAMESPACE,
            }),
            {
              headers: { 'Content-Type': 'application/json' },
              timeout: '60s',
              tags: { attack_type: 'chaos_random', severity: randomSeverity },
            }
          );
          
          // Try to get random exploit via catalog
          const catalogRes = http.get(`${BASE_URL}/catalog?severity=${randomSeverity}`, { timeout: '10s' });
          if (catalogRes.status === 200) {
            try {
              const catalog = JSON.parse(catalogRes.body);
              if (catalog.exploits && catalog.exploits.length > 0) {
                const randomExploit = catalog.exploits[Math.floor(Math.random() * catalog.exploits.length)];
                exploitId = randomExploit.id || 'random';
              }
            } catch (e) {
              // Ignore
            }
          }
        } else {
          // Pick random exploit from list
          exploitId = ALL_EXPLOITS[Math.floor(Math.random() * ALL_EXPLOITS.length)];
          
          exploitRes = http.post(
            `${BASE_URL}/exploit/run`,
            JSON.stringify({
              exploit_id: exploitId,
              namespace: TARGET_NAMESPACE,
            }),
            {
              headers: { 'Content-Type': 'application/json' },
              timeout: '60s',
              tags: { attack_type: 'chaos_specific', exploit_id: exploitId },
            }
          );
        }
        
        const startTime = Date.now();
        const duration = Date.now() - startTime;
        chaosDuration.add(duration, { exploit_id: exploitId });
        chaosIntensity.add(1);
        
        const exploitOk = check(exploitRes, {
          'chaos exploit request succeeds': (r) => r.status >= 200 && r.status < 300,
        });
        
        if (exploitOk) {
          randomExploitExecuted.add(1, { exploit_id: exploitId });
          
          try {
            const body = JSON.parse(exploitRes.body);
            const status = body.status || 'unknown';
            
            if (status === 'success') {
              randomExploitSuccess.add(1, { exploit_id: exploitId });
            } else if (status === 'blocked') {
              randomExploitBlocked.add(1, { exploit_id: exploitId });
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
        
        // Random sleep between 0.5s and 3s (chaotic timing)
        sleep(Math.random() * 2.5 + 0.5);
      });
    }
    
    export function handleSummary(data) {
      const executedMetric = data.metrics['chaos_random_exploit_executed'];
      const successMetric = data.metrics['chaos_random_exploit_success'];
      const blockedMetric = data.metrics['chaos_random_exploit_blocked'];
      const durationMetric = data.metrics['chaos_exploit_duration_ms'];
      const intensityMetric = data.metrics['chaos_intensity'];
      
      const executedCount = (executedMetric && executedMetric.values && executedMetric.values.count) || 0;
      const successRate = (successMetric && successMetric.values && successMetric.values.rate) || 0;
      const blockedRate = (blockedMetric && blockedMetric.values && blockedMetric.values.rate) || 0;
      const p95Duration = (durationMetric && durationMetric.values && durationMetric.values['p(95)']) || 0;
      const totalIntensity = (intensityMetric && intensityMetric.values && intensityMetric.values.count) || 0;
      
      console.log('\n' + 'â•'.repeat(70));
      console.log('ðŸ”´ RANDOM EXPLOIT CHAOS TEST RESULTS');
      console.log('â•'.repeat(70));
      console.log(`Random Exploits Executed: ${executedCount}`);
      console.log(`Total Chaos Intensity: ${totalIntensity}`);
      console.log(`Success Rate: ${(successRate * 100).toFixed(1)}%`);
      console.log(`Blocked Rate: ${(blockedRate * 100).toFixed(1)}%`);
      console.log(`P95 Duration: ${(p95Duration || 0).toFixed(0)}ms`);
      console.log('â•'.repeat(70) + '\n');
      
      return {};
    }
