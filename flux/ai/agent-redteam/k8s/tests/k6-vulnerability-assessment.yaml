# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
#
#  üî¥ K6 VULNERABILITY ASSESSMENT TEST - AGENT-REDTEAM
#
#  Purpose: Simulate a comprehensive vulnerability assessment
#  Scenario: Security team performing full vulnerability assessment
#            - Catalog discovery
#            - Test by severity
#            - Test by category
#            - Full test suite execution
#
# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
---
apiVersion: k6.io/v1alpha1
kind: TestRun
metadata:
  name: agent-redteam-vulnerability-assessment
  namespace: agent-redteam
  labels:
    app.kubernetes.io/name: agent-redteam
    app.kubernetes.io/component: testing
    test-type: vulnerability-assessment
spec:
  parallelism: 1
  arguments: -o experimental-prometheus-rw
  script:
    configMap:
      name: agent-redteam-vulnerability-assessment-script
      file: script.js
  runner:
    image: localhost:5001/k6:0.47.0
    env:
      - name: TARGET_URL
        value: "http://agent-redteam.agent-redteam.svc.cluster.local"
      - name: TARGET_NAMESPACE
        value: "redteam-test"
      - name: K6_PROMETHEUS_RW_SERVER_URL
        value: "http://kube-prometheus-stack-prometheus.prometheus.svc.cluster.local:9090/api/v1/write"
      - name: K6_PROMETHEUS_RW_TREND_AS_NATIVE_HISTOGRAM
        value: "true"
    resources:
      limits:
        memory: 512Mi
        cpu: 500m

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-redteam-vulnerability-assessment-script
  namespace: agent-redteam
  labels:
    app.kubernetes.io/name: agent-redteam
    app.kubernetes.io/component: testing
    test-type: vulnerability-assessment
data:
  script.js: |
    import http from 'k6/http';
    import { check, group, sleep } from 'k6';
    import { Rate, Counter, Trend } from 'k6/metrics';
    
    // Custom Metrics
    const assessmentPhaseComplete = new Counter('assessment_phase_complete');
    const criticalExploitsTested = new Counter('critical_exploits_tested');
    const highExploitsTested = new Counter('high_exploits_tested');
    const mediumExploitsTested = new Counter('medium_exploits_tested');
    const vulnerabilitiesFound = new Counter('vulnerabilities_found');
    const assessmentDuration = new Trend('assessment_duration_ms');
    
    // Configuration
    const BASE_URL = __ENV.TARGET_URL || 'http://agent-redteam.agent-redteam.svc.cluster.local';
    const TARGET_NAMESPACE = __ENV.TARGET_NAMESPACE || 'redteam-test';
    
    // Exploits by severity
    const CRITICAL_EXPLOITS = ['vuln-001', 'vuln-002', 'vuln-003', 'blue-001', 'blue-002'];
    const HIGH_EXPLOITS = ['blue-005', 'blue-006', 'vuln-004'];
    const MEDIUM_EXPLOITS = ['vuln-013'];
    
    export const options = {
      scenarios: {
        vulnerability_assessment: {
          executor: 'shared-iterations',
          vus: 1,
          iterations: 1,
          maxDuration: '15m',
        },
      },
      thresholds: {
        'assessment_phase_complete': ['count>=4'], // All phases should complete
        'http_req_failed': ['rate<0.1'],
      },
    };
    
    export default function() {
      const assessmentStart = Date.now();
      
      // Phase 1: Catalog Discovery
      group('Phase 1: Catalog Discovery', () => {
        const catalogRes = http.get(`${BASE_URL}/catalog`, { timeout: '10s' });
        check(catalogRes, {
          'catalog accessible': (r) => r.status === 200,
        });
        
        const categoriesRes = http.get(`${BASE_URL}/categories`, { timeout: '10s' });
        check(categoriesRes, {
          'categories accessible': (r) => r.status === 200,
        });
        
        const severitiesRes = http.get(`${BASE_URL}/severities`, { timeout: '10s' });
        check(severitiesRes, {
          'severities accessible': (r) => r.status === 200,
        });
        
        assessmentPhaseComplete.add(1, { phase: 'discovery' });
        sleep(2);
      });
      
      // Phase 2: Critical Severity Assessment
      group('Phase 2: Critical Severity Assessment', () => {
        for (const exploitId of CRITICAL_EXPLOITS) {
          const exploitRes = http.post(
            `${BASE_URL}/exploit/run`,
            JSON.stringify({
              exploit_id: exploitId,
              namespace: TARGET_NAMESPACE,
            }),
            {
              headers: { 'Content-Type': 'application/json' },
              timeout: '60s',
            }
          );
          
          if (exploitRes.status === 200) {
            try {
              const body = JSON.parse(exploitRes.body);
              if (body.status === 'success') {
                vulnerabilitiesFound.add(1, { severity: 'critical', exploit_id: exploitId });
              }
              criticalExploitsTested.add(1, { exploit_id: exploitId });
            } catch (e) {
              // Ignore parse errors
            }
          }
          
          sleep(1);
        }
        
        assessmentPhaseComplete.add(1, { phase: 'critical' });
        sleep(3);
      });
      
      // Phase 3: High Severity Assessment
      group('Phase 3: High Severity Assessment', () => {
        for (const exploitId of HIGH_EXPLOITS) {
          const exploitRes = http.post(
            `${BASE_URL}/exploit/run`,
            JSON.stringify({
              exploit_id: exploitId,
              namespace: TARGET_NAMESPACE,
            }),
            {
              headers: { 'Content-Type': 'application/json' },
              timeout: '60s',
            }
          );
          
          if (exploitRes.status === 200) {
            try {
              const body = JSON.parse(exploitRes.body);
              if (body.status === 'success') {
                vulnerabilitiesFound.add(1, { severity: 'high', exploit_id: exploitId });
              }
              highExploitsTested.add(1, { exploit_id: exploitId });
            } catch (e) {
              // Ignore parse errors
            }
          }
          
          sleep(1);
        }
        
        assessmentPhaseComplete.add(1, { phase: 'high' });
        sleep(3);
      });
      
      // Phase 4: Medium Severity Assessment
      group('Phase 4: Medium Severity Assessment', () => {
        for (const exploitId of MEDIUM_EXPLOITS) {
          const exploitRes = http.post(
            `${BASE_URL}/exploit/run`,
            JSON.stringify({
              exploit_id: exploitId,
              namespace: TARGET_NAMESPACE,
            }),
            {
              headers: { 'Content-Type': 'application/json' },
              timeout: '60s',
            }
          );
          
          if (exploitRes.status === 200) {
            try {
              const body = JSON.parse(exploitRes.body);
              if (body.status === 'success') {
                vulnerabilitiesFound.add(1, { severity: 'medium', exploit_id: exploitId });
              }
              mediumExploitsTested.add(1, { exploit_id: exploitId });
            } catch (e) {
              // Ignore parse errors
            }
          }
          
          sleep(1);
        }
        
        assessmentPhaseComplete.add(1, { phase: 'medium' });
      });
      
      // Phase 5: Full Test Suite
      group('Phase 5: Full Test Suite Execution', () => {
        const testRunRes = http.post(
          `${BASE_URL}/test/run`,
          JSON.stringify({
            name: 'full-vulnerability-assessment',
            namespace: TARGET_NAMESPACE,
          }),
          {
            headers: { 'Content-Type': 'application/json' },
            timeout: '300s', // 5 minutes for full suite
          }
        );
        
        check(testRunRes, {
          'full test suite executed': (r) => r.status === 200,
        });
        
        assessmentPhaseComplete.add(1, { phase: 'full_suite' });
      });
      
      const assessmentEnd = Date.now();
      const totalDuration = assessmentEnd - assessmentStart;
      assessmentDuration.add(totalDuration);
    }
    
    export function handleSummary(data) {
      const phaseMetric = data.metrics['assessment_phase_complete'];
      const criticalMetric = data.metrics['critical_exploits_tested'];
      const highMetric = data.metrics['high_exploits_tested'];
      const mediumMetric = data.metrics['medium_exploits_tested'];
      const vulnMetric = data.metrics['vulnerabilities_found'];
      const durationMetric = data.metrics['assessment_duration_ms'];
      
      const phasesComplete = (phaseMetric && phaseMetric.values && phaseMetric.values.count) || 0;
      const criticalCount = (criticalMetric && criticalMetric.values && criticalMetric.values.count) || 0;
      const highCount = (highMetric && highMetric.values && highMetric.values.count) || 0;
      const mediumCount = (mediumMetric && mediumMetric.values && mediumMetric.values.count) || 0;
      const vulnCount = (vulnMetric && vulnMetric.values && vulnMetric.values.count) || 0;
      const totalDuration = (durationMetric && durationMetric.values && durationMetric.values.avg) || 0;
      
      console.log('\n' + '‚ïê'.repeat(70));
      console.log('üî¥ VULNERABILITY ASSESSMENT TEST RESULTS');
      console.log('‚ïê'.repeat(70));
      console.log(`Assessment Phases Completed: ${phasesComplete}/5`);
      console.log(`Critical Exploits Tested: ${criticalCount}`);
      console.log(`High Exploits Tested: ${highCount}`);
      console.log(`Medium Exploits Tested: ${mediumCount}`);
      console.log(`Vulnerabilities Found: ${vulnCount}`);
      console.log(`Total Assessment Duration: ${(totalDuration / 1000).toFixed(1)}s`);
      console.log('‚ïê'.repeat(70) + '\n');
      
      return {};
    }
