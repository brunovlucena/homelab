// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: services/blockchain_manager/v1/blockchain_manager.proto

package blockchain_manager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BlockchainManager_ValidateSignature_FullMethodName        = "/services.blockchain_manager.v1.BlockchainManager/ValidateSignature"
	BlockchainManager_GetBlockWithLogs_FullMethodName         = "/services.blockchain_manager.v1.BlockchainManager/GetBlockWithLogs"
	BlockchainManager_GetBlockHeight_FullMethodName           = "/services.blockchain_manager.v1.BlockchainManager/GetBlockHeight"
	BlockchainManager_GetLatestEpoch_FullMethodName           = "/services.blockchain_manager.v1.BlockchainManager/GetLatestEpoch"
	BlockchainManager_ValidateMessageSignature_FullMethodName = "/services.blockchain_manager.v1.BlockchainManager/ValidateMessageSignature"
	BlockchainManager_GetTransactionByHash_FullMethodName     = "/services.blockchain_manager.v1.BlockchainManager/GetTransactionByHash"
)

// BlockchainManagerClient is the client API for BlockchainManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service meant to be used by internal Notifi services. None of these should ever be reachable from FusionHosts
type BlockchainManagerClient interface {
	ValidateSignature(ctx context.Context, in *SignatureValidationRequest, opts ...grpc.CallOption) (*SignatureValidationResponse, error)
	GetBlockWithLogs(ctx context.Context, in *GetBlockWithLogsRequest, opts ...grpc.CallOption) (*GetBlockWithLogsResponse, error)
	GetBlockHeight(ctx context.Context, in *GetBlockHeightRequest, opts ...grpc.CallOption) (*GetBlockHeightResponse, error)
	GetLatestEpoch(ctx context.Context, in *BcmGetLatestEpochNumberRequest, opts ...grpc.CallOption) (*BcmGetLatestEpochNumberResponse, error)
	ValidateMessageSignature(ctx context.Context, in *ValidateMessageSignatureRequest, opts ...grpc.CallOption) (*ValidateMessageSignatureResponse, error)
	GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*GetTransactionByHashResponse, error)
}

type blockchainManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockchainManagerClient(cc grpc.ClientConnInterface) BlockchainManagerClient {
	return &blockchainManagerClient{cc}
}

func (c *blockchainManagerClient) ValidateSignature(ctx context.Context, in *SignatureValidationRequest, opts ...grpc.CallOption) (*SignatureValidationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignatureValidationResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_ValidateSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainManagerClient) GetBlockWithLogs(ctx context.Context, in *GetBlockWithLogsRequest, opts ...grpc.CallOption) (*GetBlockWithLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockWithLogsResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_GetBlockWithLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainManagerClient) GetBlockHeight(ctx context.Context, in *GetBlockHeightRequest, opts ...grpc.CallOption) (*GetBlockHeightResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockHeightResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_GetBlockHeight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainManagerClient) GetLatestEpoch(ctx context.Context, in *BcmGetLatestEpochNumberRequest, opts ...grpc.CallOption) (*BcmGetLatestEpochNumberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetLatestEpochNumberResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_GetLatestEpoch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainManagerClient) ValidateMessageSignature(ctx context.Context, in *ValidateMessageSignatureRequest, opts ...grpc.CallOption) (*ValidateMessageSignatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateMessageSignatureResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_ValidateMessageSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainManagerClient) GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*GetTransactionByHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionByHashResponse)
	err := c.cc.Invoke(ctx, BlockchainManager_GetTransactionByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockchainManagerServer is the server API for BlockchainManager service.
// All implementations must embed UnimplementedBlockchainManagerServer
// for forward compatibility.
//
// Service meant to be used by internal Notifi services. None of these should ever be reachable from FusionHosts
type BlockchainManagerServer interface {
	ValidateSignature(context.Context, *SignatureValidationRequest) (*SignatureValidationResponse, error)
	GetBlockWithLogs(context.Context, *GetBlockWithLogsRequest) (*GetBlockWithLogsResponse, error)
	GetBlockHeight(context.Context, *GetBlockHeightRequest) (*GetBlockHeightResponse, error)
	GetLatestEpoch(context.Context, *BcmGetLatestEpochNumberRequest) (*BcmGetLatestEpochNumberResponse, error)
	ValidateMessageSignature(context.Context, *ValidateMessageSignatureRequest) (*ValidateMessageSignatureResponse, error)
	GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*GetTransactionByHashResponse, error)
	mustEmbedUnimplementedBlockchainManagerServer()
}

// UnimplementedBlockchainManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBlockchainManagerServer struct{}

func (UnimplementedBlockchainManagerServer) ValidateSignature(context.Context, *SignatureValidationRequest) (*SignatureValidationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateSignature not implemented")
}
func (UnimplementedBlockchainManagerServer) GetBlockWithLogs(context.Context, *GetBlockWithLogsRequest) (*GetBlockWithLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBlockWithLogs not implemented")
}
func (UnimplementedBlockchainManagerServer) GetBlockHeight(context.Context, *GetBlockHeightRequest) (*GetBlockHeightResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBlockHeight not implemented")
}
func (UnimplementedBlockchainManagerServer) GetLatestEpoch(context.Context, *BcmGetLatestEpochNumberRequest) (*BcmGetLatestEpochNumberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestEpoch not implemented")
}
func (UnimplementedBlockchainManagerServer) ValidateMessageSignature(context.Context, *ValidateMessageSignatureRequest) (*ValidateMessageSignatureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateMessageSignature not implemented")
}
func (UnimplementedBlockchainManagerServer) GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*GetTransactionByHashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (UnimplementedBlockchainManagerServer) mustEmbedUnimplementedBlockchainManagerServer() {}
func (UnimplementedBlockchainManagerServer) testEmbeddedByValue()                           {}

// UnsafeBlockchainManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockchainManagerServer will
// result in compilation errors.
type UnsafeBlockchainManagerServer interface {
	mustEmbedUnimplementedBlockchainManagerServer()
}

func RegisterBlockchainManagerServer(s grpc.ServiceRegistrar, srv BlockchainManagerServer) {
	// If the following call panics, it indicates UnimplementedBlockchainManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BlockchainManager_ServiceDesc, srv)
}

func _BlockchainManager_ValidateSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignatureValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).ValidateSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_ValidateSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).ValidateSignature(ctx, req.(*SignatureValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainManager_GetBlockWithLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockWithLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).GetBlockWithLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_GetBlockWithLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).GetBlockWithLogs(ctx, req.(*GetBlockWithLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainManager_GetBlockHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).GetBlockHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_GetBlockHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).GetBlockHeight(ctx, req.(*GetBlockHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainManager_GetLatestEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetLatestEpochNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).GetLatestEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_GetLatestEpoch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).GetLatestEpoch(ctx, req.(*BcmGetLatestEpochNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainManager_ValidateMessageSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateMessageSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).ValidateMessageSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_ValidateMessageSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).ValidateMessageSignature(ctx, req.(*ValidateMessageSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainManager_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainManagerServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockchainManager_GetTransactionByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainManagerServer).GetTransactionByHash(ctx, req.(*GetTransactionByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlockchainManager_ServiceDesc is the grpc.ServiceDesc for BlockchainManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlockchainManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.blockchain_manager.v1.BlockchainManager",
	HandlerType: (*BlockchainManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateSignature",
			Handler:    _BlockchainManager_ValidateSignature_Handler,
		},
		{
			MethodName: "GetBlockWithLogs",
			Handler:    _BlockchainManager_GetBlockWithLogs_Handler,
		},
		{
			MethodName: "GetBlockHeight",
			Handler:    _BlockchainManager_GetBlockHeight_Handler,
		},
		{
			MethodName: "GetLatestEpoch",
			Handler:    _BlockchainManager_GetLatestEpoch_Handler,
		},
		{
			MethodName: "ValidateMessageSignature",
			Handler:    _BlockchainManager_ValidateMessageSignature_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _BlockchainManager_GetTransactionByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/blockchain_manager/v1/blockchain_manager.proto",
}

const (
	FusionEvmRpc_RunEthCall_FullMethodName        = "/services.blockchain_manager.v1.FusionEvmRpc/RunEthCall"
	FusionEvmRpc_GetAccountBalance_FullMethodName = "/services.blockchain_manager.v1.FusionEvmRpc/GetAccountBalance"
)

// FusionEvmRpcClient is the client API for FusionEvmRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Fusion* services below are meant to be reachable from FusionHosts. Every entrypoint MUST require a contextId as the first parameter
// contextId should be used to validate the caller, meter the usage, and log the request with any information if needed
type FusionEvmRpcClient interface {
	RunEthCall(ctx context.Context, in *EthCallRequest, opts ...grpc.CallOption) (*EthCallResponse, error)
	GetAccountBalance(ctx context.Context, in *GetAccountBalanceRequest, opts ...grpc.CallOption) (*GetAccountBalanceResponse, error)
}

type fusionEvmRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewFusionEvmRpcClient(cc grpc.ClientConnInterface) FusionEvmRpcClient {
	return &fusionEvmRpcClient{cc}
}

func (c *fusionEvmRpcClient) RunEthCall(ctx context.Context, in *EthCallRequest, opts ...grpc.CallOption) (*EthCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EthCallResponse)
	err := c.cc.Invoke(ctx, FusionEvmRpc_RunEthCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionEvmRpcClient) GetAccountBalance(ctx context.Context, in *GetAccountBalanceRequest, opts ...grpc.CallOption) (*GetAccountBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountBalanceResponse)
	err := c.cc.Invoke(ctx, FusionEvmRpc_GetAccountBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FusionEvmRpcServer is the server API for FusionEvmRpc service.
// All implementations must embed UnimplementedFusionEvmRpcServer
// for forward compatibility.
//
// Fusion* services below are meant to be reachable from FusionHosts. Every entrypoint MUST require a contextId as the first parameter
// contextId should be used to validate the caller, meter the usage, and log the request with any information if needed
type FusionEvmRpcServer interface {
	RunEthCall(context.Context, *EthCallRequest) (*EthCallResponse, error)
	GetAccountBalance(context.Context, *GetAccountBalanceRequest) (*GetAccountBalanceResponse, error)
	mustEmbedUnimplementedFusionEvmRpcServer()
}

// UnimplementedFusionEvmRpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFusionEvmRpcServer struct{}

func (UnimplementedFusionEvmRpcServer) RunEthCall(context.Context, *EthCallRequest) (*EthCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunEthCall not implemented")
}
func (UnimplementedFusionEvmRpcServer) GetAccountBalance(context.Context, *GetAccountBalanceRequest) (*GetAccountBalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAccountBalance not implemented")
}
func (UnimplementedFusionEvmRpcServer) mustEmbedUnimplementedFusionEvmRpcServer() {}
func (UnimplementedFusionEvmRpcServer) testEmbeddedByValue()                      {}

// UnsafeFusionEvmRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FusionEvmRpcServer will
// result in compilation errors.
type UnsafeFusionEvmRpcServer interface {
	mustEmbedUnimplementedFusionEvmRpcServer()
}

func RegisterFusionEvmRpcServer(s grpc.ServiceRegistrar, srv FusionEvmRpcServer) {
	// If the following call panics, it indicates UnimplementedFusionEvmRpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FusionEvmRpc_ServiceDesc, srv)
}

func _FusionEvmRpc_RunEthCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionEvmRpcServer).RunEthCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionEvmRpc_RunEthCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionEvmRpcServer).RunEthCall(ctx, req.(*EthCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionEvmRpc_GetAccountBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionEvmRpcServer).GetAccountBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionEvmRpc_GetAccountBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionEvmRpcServer).GetAccountBalance(ctx, req.(*GetAccountBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FusionEvmRpc_ServiceDesc is the grpc.ServiceDesc for FusionEvmRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FusionEvmRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.blockchain_manager.v1.FusionEvmRpc",
	HandlerType: (*FusionEvmRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunEthCall",
			Handler:    _FusionEvmRpc_RunEthCall_Handler,
		},
		{
			MethodName: "GetAccountBalance",
			Handler:    _FusionEvmRpc_GetAccountBalance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/blockchain_manager/v1/blockchain_manager.proto",
}

const (
	FusionSuiRpc_GetSuiAccountBalance_FullMethodName        = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiAccountBalance"
	FusionSuiRpc_RunSuiTransaction_FullMethodName           = "/services.blockchain_manager.v1.FusionSuiRpc/RunSuiTransaction"
	FusionSuiRpc_RunSuiDryTransaction_FullMethodName        = "/services.blockchain_manager.v1.FusionSuiRpc/RunSuiDryTransaction"
	FusionSuiRpc_GetSuiObject_FullMethodName                = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiObject"
	FusionSuiRpc_GetSuiCoinMetadata_FullMethodName          = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiCoinMetadata"
	FusionSuiRpc_GetSuiCoinSupply_FullMethodName            = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiCoinSupply"
	FusionSuiRpc_GetSuiTransactionBlock_FullMethodName      = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiTransactionBlock"
	FusionSuiRpc_GetSuiDynamicFieldObject_FullMethodName    = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiDynamicFieldObject"
	FusionSuiRpc_RunSuiDevInspectTransaction_FullMethodName = "/services.blockchain_manager.v1.FusionSuiRpc/RunSuiDevInspectTransaction"
	FusionSuiRpc_GetSuiOwnedObjects_FullMethodName          = "/services.blockchain_manager.v1.FusionSuiRpc/GetSuiOwnedObjects"
)

// FusionSuiRpcClient is the client API for FusionSuiRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FusionSuiRpcClient interface {
	GetSuiAccountBalance(ctx context.Context, in *BcmGetSuiAccountBalanceRequest, opts ...grpc.CallOption) (*BcmGetSuiAccountBalanceResponse, error)
	RunSuiTransaction(ctx context.Context, in *BcmRunSuiTransactionCallRequest, opts ...grpc.CallOption) (*BcmRunSuiTransactionCallResponse, error)
	RunSuiDryTransaction(ctx context.Context, in *BcmRunSuiDryTransactionCallRequest, opts ...grpc.CallOption) (*BcmRunSuiDryTransactionCallResponse, error)
	GetSuiObject(ctx context.Context, in *BcmGetSuiObjectRequest, opts ...grpc.CallOption) (*BcmGetSuiObjectResponse, error)
	GetSuiCoinMetadata(ctx context.Context, in *BcmGetSuiCoinMetadataRequest, opts ...grpc.CallOption) (*BcmGetSuiCoinMetadataResponse, error)
	GetSuiCoinSupply(ctx context.Context, in *BcmGetSuiCoinSupplyRequest, opts ...grpc.CallOption) (*BcmGetSuiCoinSupplyResponse, error)
	GetSuiTransactionBlock(ctx context.Context, in *BcmGetSuiTransactionBlockRequest, opts ...grpc.CallOption) (*BcmGetSuiTransactionBlockResponse, error)
	GetSuiDynamicFieldObject(ctx context.Context, in *BcmGetSuiDynamicFieldObjectRequest, opts ...grpc.CallOption) (*BcmGetSuiDynamicFieldObjectResponse, error)
	RunSuiDevInspectTransaction(ctx context.Context, in *BcmRunSuiDevInspectTransactionRequest, opts ...grpc.CallOption) (*BcmRunSuiDevInspectTransactionResponse, error)
	GetSuiOwnedObjects(ctx context.Context, in *BcmGetSuiOwnedObjectsRequest, opts ...grpc.CallOption) (*BcmGetSuiOwnedObjectsResponse, error)
}

type fusionSuiRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewFusionSuiRpcClient(cc grpc.ClientConnInterface) FusionSuiRpcClient {
	return &fusionSuiRpcClient{cc}
}

func (c *fusionSuiRpcClient) GetSuiAccountBalance(ctx context.Context, in *BcmGetSuiAccountBalanceRequest, opts ...grpc.CallOption) (*BcmGetSuiAccountBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiAccountBalanceResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiAccountBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) RunSuiTransaction(ctx context.Context, in *BcmRunSuiTransactionCallRequest, opts ...grpc.CallOption) (*BcmRunSuiTransactionCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmRunSuiTransactionCallResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_RunSuiTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) RunSuiDryTransaction(ctx context.Context, in *BcmRunSuiDryTransactionCallRequest, opts ...grpc.CallOption) (*BcmRunSuiDryTransactionCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmRunSuiDryTransactionCallResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_RunSuiDryTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiObject(ctx context.Context, in *BcmGetSuiObjectRequest, opts ...grpc.CallOption) (*BcmGetSuiObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiObjectResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiCoinMetadata(ctx context.Context, in *BcmGetSuiCoinMetadataRequest, opts ...grpc.CallOption) (*BcmGetSuiCoinMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiCoinMetadataResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiCoinMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiCoinSupply(ctx context.Context, in *BcmGetSuiCoinSupplyRequest, opts ...grpc.CallOption) (*BcmGetSuiCoinSupplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiCoinSupplyResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiCoinSupply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiTransactionBlock(ctx context.Context, in *BcmGetSuiTransactionBlockRequest, opts ...grpc.CallOption) (*BcmGetSuiTransactionBlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiTransactionBlockResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiTransactionBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiDynamicFieldObject(ctx context.Context, in *BcmGetSuiDynamicFieldObjectRequest, opts ...grpc.CallOption) (*BcmGetSuiDynamicFieldObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiDynamicFieldObjectResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiDynamicFieldObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) RunSuiDevInspectTransaction(ctx context.Context, in *BcmRunSuiDevInspectTransactionRequest, opts ...grpc.CallOption) (*BcmRunSuiDevInspectTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmRunSuiDevInspectTransactionResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_RunSuiDevInspectTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSuiRpcClient) GetSuiOwnedObjects(ctx context.Context, in *BcmGetSuiOwnedObjectsRequest, opts ...grpc.CallOption) (*BcmGetSuiOwnedObjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSuiOwnedObjectsResponse)
	err := c.cc.Invoke(ctx, FusionSuiRpc_GetSuiOwnedObjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FusionSuiRpcServer is the server API for FusionSuiRpc service.
// All implementations must embed UnimplementedFusionSuiRpcServer
// for forward compatibility.
type FusionSuiRpcServer interface {
	GetSuiAccountBalance(context.Context, *BcmGetSuiAccountBalanceRequest) (*BcmGetSuiAccountBalanceResponse, error)
	RunSuiTransaction(context.Context, *BcmRunSuiTransactionCallRequest) (*BcmRunSuiTransactionCallResponse, error)
	RunSuiDryTransaction(context.Context, *BcmRunSuiDryTransactionCallRequest) (*BcmRunSuiDryTransactionCallResponse, error)
	GetSuiObject(context.Context, *BcmGetSuiObjectRequest) (*BcmGetSuiObjectResponse, error)
	GetSuiCoinMetadata(context.Context, *BcmGetSuiCoinMetadataRequest) (*BcmGetSuiCoinMetadataResponse, error)
	GetSuiCoinSupply(context.Context, *BcmGetSuiCoinSupplyRequest) (*BcmGetSuiCoinSupplyResponse, error)
	GetSuiTransactionBlock(context.Context, *BcmGetSuiTransactionBlockRequest) (*BcmGetSuiTransactionBlockResponse, error)
	GetSuiDynamicFieldObject(context.Context, *BcmGetSuiDynamicFieldObjectRequest) (*BcmGetSuiDynamicFieldObjectResponse, error)
	RunSuiDevInspectTransaction(context.Context, *BcmRunSuiDevInspectTransactionRequest) (*BcmRunSuiDevInspectTransactionResponse, error)
	GetSuiOwnedObjects(context.Context, *BcmGetSuiOwnedObjectsRequest) (*BcmGetSuiOwnedObjectsResponse, error)
	mustEmbedUnimplementedFusionSuiRpcServer()
}

// UnimplementedFusionSuiRpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFusionSuiRpcServer struct{}

func (UnimplementedFusionSuiRpcServer) GetSuiAccountBalance(context.Context, *BcmGetSuiAccountBalanceRequest) (*BcmGetSuiAccountBalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiAccountBalance not implemented")
}
func (UnimplementedFusionSuiRpcServer) RunSuiTransaction(context.Context, *BcmRunSuiTransactionCallRequest) (*BcmRunSuiTransactionCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunSuiTransaction not implemented")
}
func (UnimplementedFusionSuiRpcServer) RunSuiDryTransaction(context.Context, *BcmRunSuiDryTransactionCallRequest) (*BcmRunSuiDryTransactionCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunSuiDryTransaction not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiObject(context.Context, *BcmGetSuiObjectRequest) (*BcmGetSuiObjectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiObject not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiCoinMetadata(context.Context, *BcmGetSuiCoinMetadataRequest) (*BcmGetSuiCoinMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiCoinMetadata not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiCoinSupply(context.Context, *BcmGetSuiCoinSupplyRequest) (*BcmGetSuiCoinSupplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiCoinSupply not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiTransactionBlock(context.Context, *BcmGetSuiTransactionBlockRequest) (*BcmGetSuiTransactionBlockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiTransactionBlock not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiDynamicFieldObject(context.Context, *BcmGetSuiDynamicFieldObjectRequest) (*BcmGetSuiDynamicFieldObjectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiDynamicFieldObject not implemented")
}
func (UnimplementedFusionSuiRpcServer) RunSuiDevInspectTransaction(context.Context, *BcmRunSuiDevInspectTransactionRequest) (*BcmRunSuiDevInspectTransactionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunSuiDevInspectTransaction not implemented")
}
func (UnimplementedFusionSuiRpcServer) GetSuiOwnedObjects(context.Context, *BcmGetSuiOwnedObjectsRequest) (*BcmGetSuiOwnedObjectsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuiOwnedObjects not implemented")
}
func (UnimplementedFusionSuiRpcServer) mustEmbedUnimplementedFusionSuiRpcServer() {}
func (UnimplementedFusionSuiRpcServer) testEmbeddedByValue()                      {}

// UnsafeFusionSuiRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FusionSuiRpcServer will
// result in compilation errors.
type UnsafeFusionSuiRpcServer interface {
	mustEmbedUnimplementedFusionSuiRpcServer()
}

func RegisterFusionSuiRpcServer(s grpc.ServiceRegistrar, srv FusionSuiRpcServer) {
	// If the following call panics, it indicates UnimplementedFusionSuiRpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FusionSuiRpc_ServiceDesc, srv)
}

func _FusionSuiRpc_GetSuiAccountBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiAccountBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiAccountBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiAccountBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiAccountBalance(ctx, req.(*BcmGetSuiAccountBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_RunSuiTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmRunSuiTransactionCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).RunSuiTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_RunSuiTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).RunSuiTransaction(ctx, req.(*BcmRunSuiTransactionCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_RunSuiDryTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmRunSuiDryTransactionCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).RunSuiDryTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_RunSuiDryTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).RunSuiDryTransaction(ctx, req.(*BcmRunSuiDryTransactionCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiObject(ctx, req.(*BcmGetSuiObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiCoinMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiCoinMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiCoinMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiCoinMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiCoinMetadata(ctx, req.(*BcmGetSuiCoinMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiCoinSupply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiCoinSupplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiCoinSupply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiCoinSupply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiCoinSupply(ctx, req.(*BcmGetSuiCoinSupplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiTransactionBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiTransactionBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiTransactionBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiTransactionBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiTransactionBlock(ctx, req.(*BcmGetSuiTransactionBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiDynamicFieldObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiDynamicFieldObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiDynamicFieldObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiDynamicFieldObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiDynamicFieldObject(ctx, req.(*BcmGetSuiDynamicFieldObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_RunSuiDevInspectTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmRunSuiDevInspectTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).RunSuiDevInspectTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_RunSuiDevInspectTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).RunSuiDevInspectTransaction(ctx, req.(*BcmRunSuiDevInspectTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSuiRpc_GetSuiOwnedObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSuiOwnedObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSuiRpcServer).GetSuiOwnedObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSuiRpc_GetSuiOwnedObjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSuiRpcServer).GetSuiOwnedObjects(ctx, req.(*BcmGetSuiOwnedObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FusionSuiRpc_ServiceDesc is the grpc.ServiceDesc for FusionSuiRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FusionSuiRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.blockchain_manager.v1.FusionSuiRpc",
	HandlerType: (*FusionSuiRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSuiAccountBalance",
			Handler:    _FusionSuiRpc_GetSuiAccountBalance_Handler,
		},
		{
			MethodName: "RunSuiTransaction",
			Handler:    _FusionSuiRpc_RunSuiTransaction_Handler,
		},
		{
			MethodName: "RunSuiDryTransaction",
			Handler:    _FusionSuiRpc_RunSuiDryTransaction_Handler,
		},
		{
			MethodName: "GetSuiObject",
			Handler:    _FusionSuiRpc_GetSuiObject_Handler,
		},
		{
			MethodName: "GetSuiCoinMetadata",
			Handler:    _FusionSuiRpc_GetSuiCoinMetadata_Handler,
		},
		{
			MethodName: "GetSuiCoinSupply",
			Handler:    _FusionSuiRpc_GetSuiCoinSupply_Handler,
		},
		{
			MethodName: "GetSuiTransactionBlock",
			Handler:    _FusionSuiRpc_GetSuiTransactionBlock_Handler,
		},
		{
			MethodName: "GetSuiDynamicFieldObject",
			Handler:    _FusionSuiRpc_GetSuiDynamicFieldObject_Handler,
		},
		{
			MethodName: "RunSuiDevInspectTransaction",
			Handler:    _FusionSuiRpc_RunSuiDevInspectTransaction_Handler,
		},
		{
			MethodName: "GetSuiOwnedObjects",
			Handler:    _FusionSuiRpc_GetSuiOwnedObjects_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/blockchain_manager/v1/blockchain_manager.proto",
}

const (
	FusionCosmosRpc_AbciQuery_FullMethodName = "/services.blockchain_manager.v1.FusionCosmosRpc/AbciQuery"
)

// FusionCosmosRpcClient is the client API for FusionCosmosRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FusionCosmosRpcClient interface {
	AbciQuery(ctx context.Context, in *AbciQueryRequest, opts ...grpc.CallOption) (*AbciQueryResponse, error)
}

type fusionCosmosRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewFusionCosmosRpcClient(cc grpc.ClientConnInterface) FusionCosmosRpcClient {
	return &fusionCosmosRpcClient{cc}
}

func (c *fusionCosmosRpcClient) AbciQuery(ctx context.Context, in *AbciQueryRequest, opts ...grpc.CallOption) (*AbciQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbciQueryResponse)
	err := c.cc.Invoke(ctx, FusionCosmosRpc_AbciQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FusionCosmosRpcServer is the server API for FusionCosmosRpc service.
// All implementations must embed UnimplementedFusionCosmosRpcServer
// for forward compatibility.
type FusionCosmosRpcServer interface {
	AbciQuery(context.Context, *AbciQueryRequest) (*AbciQueryResponse, error)
	mustEmbedUnimplementedFusionCosmosRpcServer()
}

// UnimplementedFusionCosmosRpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFusionCosmosRpcServer struct{}

func (UnimplementedFusionCosmosRpcServer) AbciQuery(context.Context, *AbciQueryRequest) (*AbciQueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AbciQuery not implemented")
}
func (UnimplementedFusionCosmosRpcServer) mustEmbedUnimplementedFusionCosmosRpcServer() {}
func (UnimplementedFusionCosmosRpcServer) testEmbeddedByValue()                         {}

// UnsafeFusionCosmosRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FusionCosmosRpcServer will
// result in compilation errors.
type UnsafeFusionCosmosRpcServer interface {
	mustEmbedUnimplementedFusionCosmosRpcServer()
}

func RegisterFusionCosmosRpcServer(s grpc.ServiceRegistrar, srv FusionCosmosRpcServer) {
	// If the following call panics, it indicates UnimplementedFusionCosmosRpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FusionCosmosRpc_ServiceDesc, srv)
}

func _FusionCosmosRpc_AbciQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbciQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionCosmosRpcServer).AbciQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionCosmosRpc_AbciQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionCosmosRpcServer).AbciQuery(ctx, req.(*AbciQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FusionCosmosRpc_ServiceDesc is the grpc.ServiceDesc for FusionCosmosRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FusionCosmosRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.blockchain_manager.v1.FusionCosmosRpc",
	HandlerType: (*FusionCosmosRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AbciQuery",
			Handler:    _FusionCosmosRpc_AbciQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/blockchain_manager/v1/blockchain_manager.proto",
}

const (
	FusionSolanaRpc_GetSolanaBalance_FullMethodName              = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaBalance"
	FusionSolanaRpc_GetSolanaAccountInfo_FullMethodName          = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaAccountInfo"
	FusionSolanaRpc_GetSolanaSlot_FullMethodName                 = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaSlot"
	FusionSolanaRpc_GetSolanaProgramAccounts_FullMethodName      = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaProgramAccounts"
	FusionSolanaRpc_GetSolanaTransaction_FullMethodName          = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaTransaction"
	FusionSolanaRpc_GetSolanaTokenAccountBalance_FullMethodName  = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaTokenAccountBalance"
	FusionSolanaRpc_GetSolanaMultipleAccounts_FullMethodName     = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaMultipleAccounts"
	FusionSolanaRpc_GetSolanaTokenAccountsByOwner_FullMethodName = "/services.blockchain_manager.v1.FusionSolanaRpc/GetSolanaTokenAccountsByOwner"
)

// FusionSolanaRpcClient is the client API for FusionSolanaRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FusionSolanaRpcClient interface {
	GetSolanaBalance(ctx context.Context, in *BcmGetSolanaBalanceRequest, opts ...grpc.CallOption) (*BcmGetSolanaBalanceResponse, error)
	GetSolanaAccountInfo(ctx context.Context, in *BcmGetSolanaAccountInfoRequest, opts ...grpc.CallOption) (*BcmGetSolanaAccountInfoResponse, error)
	GetSolanaSlot(ctx context.Context, in *BcmGetSolanaSlotRequest, opts ...grpc.CallOption) (*BcmGetSolanaSlotResponse, error)
	GetSolanaProgramAccounts(ctx context.Context, in *BcmGetSolanaProgramAccountsRequest, opts ...grpc.CallOption) (*BcmGetSolanaProgramAccountsResponse, error)
	GetSolanaTransaction(ctx context.Context, in *BcmGetSolanaTransactionRequest, opts ...grpc.CallOption) (*BcmGetSolanaTransactionResponse, error)
	GetSolanaTokenAccountBalance(ctx context.Context, in *BcmGetSolanaTokenAccountBalanceRequest, opts ...grpc.CallOption) (*BcmGetSolanaTokenAccountBalanceResponse, error)
	GetSolanaMultipleAccounts(ctx context.Context, in *BcmGetSolanaMultipleAccountsRequest, opts ...grpc.CallOption) (*BcmGetSolanaMultipleAccountsResponse, error)
	GetSolanaTokenAccountsByOwner(ctx context.Context, in *BcmGetSolanaTokenAccountsByOwnerRequest, opts ...grpc.CallOption) (*BcmGetSolanaTokenAccountsByOwnerResponse, error)
}

type fusionSolanaRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewFusionSolanaRpcClient(cc grpc.ClientConnInterface) FusionSolanaRpcClient {
	return &fusionSolanaRpcClient{cc}
}

func (c *fusionSolanaRpcClient) GetSolanaBalance(ctx context.Context, in *BcmGetSolanaBalanceRequest, opts ...grpc.CallOption) (*BcmGetSolanaBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaBalanceResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaAccountInfo(ctx context.Context, in *BcmGetSolanaAccountInfoRequest, opts ...grpc.CallOption) (*BcmGetSolanaAccountInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaAccountInfoResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaAccountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaSlot(ctx context.Context, in *BcmGetSolanaSlotRequest, opts ...grpc.CallOption) (*BcmGetSolanaSlotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaSlotResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaSlot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaProgramAccounts(ctx context.Context, in *BcmGetSolanaProgramAccountsRequest, opts ...grpc.CallOption) (*BcmGetSolanaProgramAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaProgramAccountsResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaProgramAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaTransaction(ctx context.Context, in *BcmGetSolanaTransactionRequest, opts ...grpc.CallOption) (*BcmGetSolanaTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaTransactionResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaTokenAccountBalance(ctx context.Context, in *BcmGetSolanaTokenAccountBalanceRequest, opts ...grpc.CallOption) (*BcmGetSolanaTokenAccountBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaTokenAccountBalanceResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaTokenAccountBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaMultipleAccounts(ctx context.Context, in *BcmGetSolanaMultipleAccountsRequest, opts ...grpc.CallOption) (*BcmGetSolanaMultipleAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaMultipleAccountsResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaMultipleAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSolanaRpcClient) GetSolanaTokenAccountsByOwner(ctx context.Context, in *BcmGetSolanaTokenAccountsByOwnerRequest, opts ...grpc.CallOption) (*BcmGetSolanaTokenAccountsByOwnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BcmGetSolanaTokenAccountsByOwnerResponse)
	err := c.cc.Invoke(ctx, FusionSolanaRpc_GetSolanaTokenAccountsByOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FusionSolanaRpcServer is the server API for FusionSolanaRpc service.
// All implementations must embed UnimplementedFusionSolanaRpcServer
// for forward compatibility.
type FusionSolanaRpcServer interface {
	GetSolanaBalance(context.Context, *BcmGetSolanaBalanceRequest) (*BcmGetSolanaBalanceResponse, error)
	GetSolanaAccountInfo(context.Context, *BcmGetSolanaAccountInfoRequest) (*BcmGetSolanaAccountInfoResponse, error)
	GetSolanaSlot(context.Context, *BcmGetSolanaSlotRequest) (*BcmGetSolanaSlotResponse, error)
	GetSolanaProgramAccounts(context.Context, *BcmGetSolanaProgramAccountsRequest) (*BcmGetSolanaProgramAccountsResponse, error)
	GetSolanaTransaction(context.Context, *BcmGetSolanaTransactionRequest) (*BcmGetSolanaTransactionResponse, error)
	GetSolanaTokenAccountBalance(context.Context, *BcmGetSolanaTokenAccountBalanceRequest) (*BcmGetSolanaTokenAccountBalanceResponse, error)
	GetSolanaMultipleAccounts(context.Context, *BcmGetSolanaMultipleAccountsRequest) (*BcmGetSolanaMultipleAccountsResponse, error)
	GetSolanaTokenAccountsByOwner(context.Context, *BcmGetSolanaTokenAccountsByOwnerRequest) (*BcmGetSolanaTokenAccountsByOwnerResponse, error)
	mustEmbedUnimplementedFusionSolanaRpcServer()
}

// UnimplementedFusionSolanaRpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFusionSolanaRpcServer struct{}

func (UnimplementedFusionSolanaRpcServer) GetSolanaBalance(context.Context, *BcmGetSolanaBalanceRequest) (*BcmGetSolanaBalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaBalance not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaAccountInfo(context.Context, *BcmGetSolanaAccountInfoRequest) (*BcmGetSolanaAccountInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaAccountInfo not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaSlot(context.Context, *BcmGetSolanaSlotRequest) (*BcmGetSolanaSlotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaSlot not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaProgramAccounts(context.Context, *BcmGetSolanaProgramAccountsRequest) (*BcmGetSolanaProgramAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaProgramAccounts not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaTransaction(context.Context, *BcmGetSolanaTransactionRequest) (*BcmGetSolanaTransactionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaTransaction not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaTokenAccountBalance(context.Context, *BcmGetSolanaTokenAccountBalanceRequest) (*BcmGetSolanaTokenAccountBalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaTokenAccountBalance not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaMultipleAccounts(context.Context, *BcmGetSolanaMultipleAccountsRequest) (*BcmGetSolanaMultipleAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaMultipleAccounts not implemented")
}
func (UnimplementedFusionSolanaRpcServer) GetSolanaTokenAccountsByOwner(context.Context, *BcmGetSolanaTokenAccountsByOwnerRequest) (*BcmGetSolanaTokenAccountsByOwnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSolanaTokenAccountsByOwner not implemented")
}
func (UnimplementedFusionSolanaRpcServer) mustEmbedUnimplementedFusionSolanaRpcServer() {}
func (UnimplementedFusionSolanaRpcServer) testEmbeddedByValue()                         {}

// UnsafeFusionSolanaRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FusionSolanaRpcServer will
// result in compilation errors.
type UnsafeFusionSolanaRpcServer interface {
	mustEmbedUnimplementedFusionSolanaRpcServer()
}

func RegisterFusionSolanaRpcServer(s grpc.ServiceRegistrar, srv FusionSolanaRpcServer) {
	// If the following call panics, it indicates UnimplementedFusionSolanaRpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FusionSolanaRpc_ServiceDesc, srv)
}

func _FusionSolanaRpc_GetSolanaBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaBalance(ctx, req.(*BcmGetSolanaBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaAccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaAccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaAccountInfo(ctx, req.(*BcmGetSolanaAccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaSlot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaSlotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaSlot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaSlot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaSlot(ctx, req.(*BcmGetSolanaSlotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaProgramAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaProgramAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaProgramAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaProgramAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaProgramAccounts(ctx, req.(*BcmGetSolanaProgramAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaTransaction(ctx, req.(*BcmGetSolanaTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaTokenAccountBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaTokenAccountBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaTokenAccountBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaTokenAccountBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaTokenAccountBalance(ctx, req.(*BcmGetSolanaTokenAccountBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaMultipleAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaMultipleAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaMultipleAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaMultipleAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaMultipleAccounts(ctx, req.(*BcmGetSolanaMultipleAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionSolanaRpc_GetSolanaTokenAccountsByOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BcmGetSolanaTokenAccountsByOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSolanaRpcServer).GetSolanaTokenAccountsByOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionSolanaRpc_GetSolanaTokenAccountsByOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSolanaRpcServer).GetSolanaTokenAccountsByOwner(ctx, req.(*BcmGetSolanaTokenAccountsByOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FusionSolanaRpc_ServiceDesc is the grpc.ServiceDesc for FusionSolanaRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FusionSolanaRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.blockchain_manager.v1.FusionSolanaRpc",
	HandlerType: (*FusionSolanaRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSolanaBalance",
			Handler:    _FusionSolanaRpc_GetSolanaBalance_Handler,
		},
		{
			MethodName: "GetSolanaAccountInfo",
			Handler:    _FusionSolanaRpc_GetSolanaAccountInfo_Handler,
		},
		{
			MethodName: "GetSolanaSlot",
			Handler:    _FusionSolanaRpc_GetSolanaSlot_Handler,
		},
		{
			MethodName: "GetSolanaProgramAccounts",
			Handler:    _FusionSolanaRpc_GetSolanaProgramAccounts_Handler,
		},
		{
			MethodName: "GetSolanaTransaction",
			Handler:    _FusionSolanaRpc_GetSolanaTransaction_Handler,
		},
		{
			MethodName: "GetSolanaTokenAccountBalance",
			Handler:    _FusionSolanaRpc_GetSolanaTokenAccountBalance_Handler,
		},
		{
			MethodName: "GetSolanaMultipleAccounts",
			Handler:    _FusionSolanaRpc_GetSolanaMultipleAccounts_Handler,
		},
		{
			MethodName: "GetSolanaTokenAccountsByOwner",
			Handler:    _FusionSolanaRpc_GetSolanaTokenAccountsByOwner_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/blockchain_manager/v1/blockchain_manager.proto",
}
