// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: services/scheduler/v1/scheduler.proto

package scheduler

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Scheduler_ScheduleEvmParse_FullMethodName               = "/services.scheduler.v1.Scheduler/ScheduleEvmParse"
	Scheduler_ScheduleSuiParse_FullMethodName               = "/services.scheduler.v1.Scheduler/ScheduleSuiParse"
	Scheduler_ScheduleEvmosParse_FullMethodName             = "/services.scheduler.v1.Scheduler/ScheduleEvmosParse"
	Scheduler_ScheduleOsmosisParse_FullMethodName           = "/services.scheduler.v1.Scheduler/ScheduleOsmosisParse"
	Scheduler_ScheduleOffchainParse_FullMethodName          = "/services.scheduler.v1.Scheduler/ScheduleOffchainParse"
	Scheduler_ScheduleSolanaParse_FullMethodName            = "/services.scheduler.v1.Scheduler/ScheduleSolanaParse"
	Scheduler_ScheduleSourceFilter_FullMethodName           = "/services.scheduler.v1.Scheduler/ScheduleSourceFilter"
	Scheduler_ScheduleAlertFilter_FullMethodName            = "/services.scheduler.v1.Scheduler/ScheduleAlertFilter"
	Scheduler_QueueOffchainEvents_FullMethodName            = "/services.scheduler.v1.Scheduler/QueueOffchainEvents"
	Scheduler_ExecuteFusionSource_FullMethodName            = "/services.scheduler.v1.Scheduler/ExecuteFusionSource"
	Scheduler_EnsureFusionSourceExecutionEnv_FullMethodName = "/services.scheduler.v1.Scheduler/EnsureFusionSourceExecutionEnv"
)

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// This service is only meant to be used by internal callers such as other Notifi services
type SchedulerClient interface {
	ScheduleEvmParse(ctx context.Context, in *ScheduleEvmParseRequest, opts ...grpc.CallOption) (*ScheduleEvmParseResponse, error)
	ScheduleSuiParse(ctx context.Context, in *ScheduleSuiParseRequest, opts ...grpc.CallOption) (*ScheduleSuiParseResponse, error)
	ScheduleEvmosParse(ctx context.Context, in *ScheduleEvmosParseRequest, opts ...grpc.CallOption) (*ScheduleEvmosParseResponse, error)
	ScheduleOsmosisParse(ctx context.Context, in *ScheduleOsmosisParseRequest, opts ...grpc.CallOption) (*ScheduleOsmosisParseResponse, error)
	ScheduleOffchainParse(ctx context.Context, in *ScheduleOffchainParseRequest, opts ...grpc.CallOption) (*ScheduleOffchainParseResponse, error)
	ScheduleSolanaParse(ctx context.Context, in *ScheduleSolanaParseRequest, opts ...grpc.CallOption) (*ScheduleSolanaParseResponse, error)
	ScheduleSourceFilter(ctx context.Context, in *ScheduleSourceFilterRequest, opts ...grpc.CallOption) (*ScheduleSourceFilterResponse, error)
	ScheduleAlertFilter(ctx context.Context, in *ScheduleAlertFilterRequest, opts ...grpc.CallOption) (*ScheduleAlertFilterResponse, error)
	QueueOffchainEvents(ctx context.Context, in *QueueOffchainEventsRequest, opts ...grpc.CallOption) (*QueueOffchainEventsResponse, error)
	// ExecuteFusionSource is a generic endpoint that can be used to execute any fusion source
	// the request blocks until execution is complete and a response is returned. This differs
	// from typical async models where the response is delivered via a callback
	ExecuteFusionSource(ctx context.Context, in *ExecuteFusionSourceRequest, opts ...grpc.CallOption) (*ExecuteFusionSourceResponse, error)
	// Parsers executed via ExecuteFusionSource will need to ensure that their execution environment is setup
	// first. Each parser here has its own lambda/host. There is no sharing as is done between Schedule* APIs.
	EnsureFusionSourceExecutionEnv(ctx context.Context, in *EnsureFusionSourceExecutionEnvRequest, opts ...grpc.CallOption) (*EnsureFusionSourceExecutionEnvResponse, error)
}

type schedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewSchedulerClient(cc grpc.ClientConnInterface) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) ScheduleEvmParse(ctx context.Context, in *ScheduleEvmParseRequest, opts ...grpc.CallOption) (*ScheduleEvmParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleEvmParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleEvmParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleSuiParse(ctx context.Context, in *ScheduleSuiParseRequest, opts ...grpc.CallOption) (*ScheduleSuiParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleSuiParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleSuiParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleEvmosParse(ctx context.Context, in *ScheduleEvmosParseRequest, opts ...grpc.CallOption) (*ScheduleEvmosParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleEvmosParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleEvmosParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleOsmosisParse(ctx context.Context, in *ScheduleOsmosisParseRequest, opts ...grpc.CallOption) (*ScheduleOsmosisParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleOsmosisParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleOsmosisParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleOffchainParse(ctx context.Context, in *ScheduleOffchainParseRequest, opts ...grpc.CallOption) (*ScheduleOffchainParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleOffchainParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleOffchainParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleSolanaParse(ctx context.Context, in *ScheduleSolanaParseRequest, opts ...grpc.CallOption) (*ScheduleSolanaParseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleSolanaParseResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleSolanaParse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleSourceFilter(ctx context.Context, in *ScheduleSourceFilterRequest, opts ...grpc.CallOption) (*ScheduleSourceFilterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleSourceFilterResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleSourceFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ScheduleAlertFilter(ctx context.Context, in *ScheduleAlertFilterRequest, opts ...grpc.CallOption) (*ScheduleAlertFilterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleAlertFilterResponse)
	err := c.cc.Invoke(ctx, Scheduler_ScheduleAlertFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) QueueOffchainEvents(ctx context.Context, in *QueueOffchainEventsRequest, opts ...grpc.CallOption) (*QueueOffchainEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueueOffchainEventsResponse)
	err := c.cc.Invoke(ctx, Scheduler_QueueOffchainEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ExecuteFusionSource(ctx context.Context, in *ExecuteFusionSourceRequest, opts ...grpc.CallOption) (*ExecuteFusionSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteFusionSourceResponse)
	err := c.cc.Invoke(ctx, Scheduler_ExecuteFusionSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) EnsureFusionSourceExecutionEnv(ctx context.Context, in *EnsureFusionSourceExecutionEnvRequest, opts ...grpc.CallOption) (*EnsureFusionSourceExecutionEnvResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureFusionSourceExecutionEnvResponse)
	err := c.cc.Invoke(ctx, Scheduler_EnsureFusionSourceExecutionEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerServer is the server API for Scheduler service.
// All implementations must embed UnimplementedSchedulerServer
// for forward compatibility.
//
// This service is only meant to be used by internal callers such as other Notifi services
type SchedulerServer interface {
	ScheduleEvmParse(context.Context, *ScheduleEvmParseRequest) (*ScheduleEvmParseResponse, error)
	ScheduleSuiParse(context.Context, *ScheduleSuiParseRequest) (*ScheduleSuiParseResponse, error)
	ScheduleEvmosParse(context.Context, *ScheduleEvmosParseRequest) (*ScheduleEvmosParseResponse, error)
	ScheduleOsmosisParse(context.Context, *ScheduleOsmosisParseRequest) (*ScheduleOsmosisParseResponse, error)
	ScheduleOffchainParse(context.Context, *ScheduleOffchainParseRequest) (*ScheduleOffchainParseResponse, error)
	ScheduleSolanaParse(context.Context, *ScheduleSolanaParseRequest) (*ScheduleSolanaParseResponse, error)
	ScheduleSourceFilter(context.Context, *ScheduleSourceFilterRequest) (*ScheduleSourceFilterResponse, error)
	ScheduleAlertFilter(context.Context, *ScheduleAlertFilterRequest) (*ScheduleAlertFilterResponse, error)
	QueueOffchainEvents(context.Context, *QueueOffchainEventsRequest) (*QueueOffchainEventsResponse, error)
	// ExecuteFusionSource is a generic endpoint that can be used to execute any fusion source
	// the request blocks until execution is complete and a response is returned. This differs
	// from typical async models where the response is delivered via a callback
	ExecuteFusionSource(context.Context, *ExecuteFusionSourceRequest) (*ExecuteFusionSourceResponse, error)
	// Parsers executed via ExecuteFusionSource will need to ensure that their execution environment is setup
	// first. Each parser here has its own lambda/host. There is no sharing as is done between Schedule* APIs.
	EnsureFusionSourceExecutionEnv(context.Context, *EnsureFusionSourceExecutionEnvRequest) (*EnsureFusionSourceExecutionEnvResponse, error)
	mustEmbedUnimplementedSchedulerServer()
}

// UnimplementedSchedulerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSchedulerServer struct{}

func (UnimplementedSchedulerServer) ScheduleEvmParse(context.Context, *ScheduleEvmParseRequest) (*ScheduleEvmParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleEvmParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleSuiParse(context.Context, *ScheduleSuiParseRequest) (*ScheduleSuiParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleSuiParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleEvmosParse(context.Context, *ScheduleEvmosParseRequest) (*ScheduleEvmosParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleEvmosParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleOsmosisParse(context.Context, *ScheduleOsmosisParseRequest) (*ScheduleOsmosisParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleOsmosisParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleOffchainParse(context.Context, *ScheduleOffchainParseRequest) (*ScheduleOffchainParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleOffchainParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleSolanaParse(context.Context, *ScheduleSolanaParseRequest) (*ScheduleSolanaParseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleSolanaParse not implemented")
}
func (UnimplementedSchedulerServer) ScheduleSourceFilter(context.Context, *ScheduleSourceFilterRequest) (*ScheduleSourceFilterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleSourceFilter not implemented")
}
func (UnimplementedSchedulerServer) ScheduleAlertFilter(context.Context, *ScheduleAlertFilterRequest) (*ScheduleAlertFilterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleAlertFilter not implemented")
}
func (UnimplementedSchedulerServer) QueueOffchainEvents(context.Context, *QueueOffchainEventsRequest) (*QueueOffchainEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method QueueOffchainEvents not implemented")
}
func (UnimplementedSchedulerServer) ExecuteFusionSource(context.Context, *ExecuteFusionSourceRequest) (*ExecuteFusionSourceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteFusionSource not implemented")
}
func (UnimplementedSchedulerServer) EnsureFusionSourceExecutionEnv(context.Context, *EnsureFusionSourceExecutionEnvRequest) (*EnsureFusionSourceExecutionEnvResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnsureFusionSourceExecutionEnv not implemented")
}
func (UnimplementedSchedulerServer) mustEmbedUnimplementedSchedulerServer() {}
func (UnimplementedSchedulerServer) testEmbeddedByValue()                   {}

// UnsafeSchedulerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchedulerServer will
// result in compilation errors.
type UnsafeSchedulerServer interface {
	mustEmbedUnimplementedSchedulerServer()
}

func RegisterSchedulerServer(s grpc.ServiceRegistrar, srv SchedulerServer) {
	// If the following call panics, it indicates UnimplementedSchedulerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Scheduler_ServiceDesc, srv)
}

func _Scheduler_ScheduleEvmParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleEvmParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleEvmParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleEvmParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleEvmParse(ctx, req.(*ScheduleEvmParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleSuiParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleSuiParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleSuiParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleSuiParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleSuiParse(ctx, req.(*ScheduleSuiParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleEvmosParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleEvmosParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleEvmosParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleEvmosParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleEvmosParse(ctx, req.(*ScheduleEvmosParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleOsmosisParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleOsmosisParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleOsmosisParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleOsmosisParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleOsmosisParse(ctx, req.(*ScheduleOsmosisParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleOffchainParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleOffchainParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleOffchainParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleOffchainParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleOffchainParse(ctx, req.(*ScheduleOffchainParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleSolanaParse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleSolanaParseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleSolanaParse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleSolanaParse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleSolanaParse(ctx, req.(*ScheduleSolanaParseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleSourceFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleSourceFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleSourceFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleSourceFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleSourceFilter(ctx, req.(*ScheduleSourceFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ScheduleAlertFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleAlertFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleAlertFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ScheduleAlertFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleAlertFilter(ctx, req.(*ScheduleAlertFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_QueueOffchainEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueOffchainEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).QueueOffchainEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_QueueOffchainEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).QueueOffchainEvents(ctx, req.(*QueueOffchainEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ExecuteFusionSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteFusionSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ExecuteFusionSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_ExecuteFusionSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ExecuteFusionSource(ctx, req.(*ExecuteFusionSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_EnsureFusionSourceExecutionEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureFusionSourceExecutionEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).EnsureFusionSourceExecutionEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_EnsureFusionSourceExecutionEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).EnsureFusionSourceExecutionEnv(ctx, req.(*EnsureFusionSourceExecutionEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Scheduler_ServiceDesc is the grpc.ServiceDesc for Scheduler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Scheduler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.scheduler.v1.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScheduleEvmParse",
			Handler:    _Scheduler_ScheduleEvmParse_Handler,
		},
		{
			MethodName: "ScheduleSuiParse",
			Handler:    _Scheduler_ScheduleSuiParse_Handler,
		},
		{
			MethodName: "ScheduleEvmosParse",
			Handler:    _Scheduler_ScheduleEvmosParse_Handler,
		},
		{
			MethodName: "ScheduleOsmosisParse",
			Handler:    _Scheduler_ScheduleOsmosisParse_Handler,
		},
		{
			MethodName: "ScheduleOffchainParse",
			Handler:    _Scheduler_ScheduleOffchainParse_Handler,
		},
		{
			MethodName: "ScheduleSolanaParse",
			Handler:    _Scheduler_ScheduleSolanaParse_Handler,
		},
		{
			MethodName: "ScheduleSourceFilter",
			Handler:    _Scheduler_ScheduleSourceFilter_Handler,
		},
		{
			MethodName: "ScheduleAlertFilter",
			Handler:    _Scheduler_ScheduleAlertFilter_Handler,
		},
		{
			MethodName: "QueueOffchainEvents",
			Handler:    _Scheduler_QueueOffchainEvents_Handler,
		},
		{
			MethodName: "ExecuteFusionSource",
			Handler:    _Scheduler_ExecuteFusionSource_Handler,
		},
		{
			MethodName: "EnsureFusionSourceExecutionEnv",
			Handler:    _Scheduler_EnsureFusionSourceExecutionEnv_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/scheduler/v1/scheduler.proto",
}

const (
	FusionScheduler_ReportEvmParseCompletion_FullMethodName      = "/services.scheduler.v1.FusionScheduler/ReportEvmParseCompletion"
	FusionScheduler_ReportEvmParseFailure_FullMethodName         = "/services.scheduler.v1.FusionScheduler/ReportEvmParseFailure"
	FusionScheduler_ReportSuiParseCompletion_FullMethodName      = "/services.scheduler.v1.FusionScheduler/ReportSuiParseCompletion"
	FusionScheduler_ReportSuiParseFailure_FullMethodName         = "/services.scheduler.v1.FusionScheduler/ReportSuiParseFailure"
	FusionScheduler_ReportEvmosParseCompletion_FullMethodName    = "/services.scheduler.v1.FusionScheduler/ReportEvmosParseCompletion"
	FusionScheduler_ReportEvmosParseFailure_FullMethodName       = "/services.scheduler.v1.FusionScheduler/ReportEvmosParseFailure"
	FusionScheduler_ReportOsmosisParseCompletion_FullMethodName  = "/services.scheduler.v1.FusionScheduler/ReportOsmosisParseCompletion"
	FusionScheduler_ReportOsmosisParseFailure_FullMethodName     = "/services.scheduler.v1.FusionScheduler/ReportOsmosisParseFailure"
	FusionScheduler_ReportOffchainParseCompletion_FullMethodName = "/services.scheduler.v1.FusionScheduler/ReportOffchainParseCompletion"
	FusionScheduler_ReportOffchainParseFailure_FullMethodName    = "/services.scheduler.v1.FusionScheduler/ReportOffchainParseFailure"
	FusionScheduler_ReportSolanaParseCompletion_FullMethodName   = "/services.scheduler.v1.FusionScheduler/ReportSolanaParseCompletion"
	FusionScheduler_ReportSolanaParseFailure_FullMethodName      = "/services.scheduler.v1.FusionScheduler/ReportSolanaParseFailure"
	FusionScheduler_ReportSourceFilterCompletion_FullMethodName  = "/services.scheduler.v1.FusionScheduler/ReportSourceFilterCompletion"
	FusionScheduler_ReportSourceFilterFailure_FullMethodName     = "/services.scheduler.v1.FusionScheduler/ReportSourceFilterFailure"
	FusionScheduler_ReportAlertFilterCompletion_FullMethodName   = "/services.scheduler.v1.FusionScheduler/ReportAlertFilterCompletion"
	FusionScheduler_ReportAlertFilterFailure_FullMethodName      = "/services.scheduler.v1.FusionScheduler/ReportAlertFilterFailure"
)

// FusionSchedulerClient is the client API for FusionScheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Fusion endpoints are meant to be called from the FusionHost
// All Fusion endpoints require messages with a context_id
type FusionSchedulerClient interface {
	ReportEvmParseCompletion(ctx context.Context, in *ReportEvmParseCompletionRequest, opts ...grpc.CallOption) (*ReportEvmParseCompletionResponse, error)
	ReportEvmParseFailure(ctx context.Context, in *ReportEvmParseFailureRequest, opts ...grpc.CallOption) (*ReportEvmParseFailureResponse, error)
	ReportSuiParseCompletion(ctx context.Context, in *ReportSuiParseCompletionRequest, opts ...grpc.CallOption) (*ReportSuiParseCompletionResponse, error)
	ReportSuiParseFailure(ctx context.Context, in *ReportSuiParseFailureRequest, opts ...grpc.CallOption) (*ReportSuiParseFailureResponse, error)
	ReportEvmosParseCompletion(ctx context.Context, in *ReportEvmosParseCompletionRequest, opts ...grpc.CallOption) (*ReportEvmosParseCompletionResponse, error)
	ReportEvmosParseFailure(ctx context.Context, in *ReportEvmosParseFailureRequest, opts ...grpc.CallOption) (*ReportEvmosParseFailureResponse, error)
	ReportOsmosisParseCompletion(ctx context.Context, in *ReportOsmosisParseCompletionRequest, opts ...grpc.CallOption) (*ReportOsmosisParseCompletionResponse, error)
	ReportOsmosisParseFailure(ctx context.Context, in *ReportOsmosisParseFailureRequest, opts ...grpc.CallOption) (*ReportOsmosisParseFailureResponse, error)
	ReportOffchainParseCompletion(ctx context.Context, in *ReportOffchainParseCompletionRequest, opts ...grpc.CallOption) (*ReportOffchainParseCompletionResponse, error)
	ReportOffchainParseFailure(ctx context.Context, in *ReportOffchainParseFailureRequest, opts ...grpc.CallOption) (*ReportOffchainParseFailureResponse, error)
	ReportSolanaParseCompletion(ctx context.Context, in *ReportSolanaParseCompletionRequest, opts ...grpc.CallOption) (*ReportSolanaParseCompletionResponse, error)
	ReportSolanaParseFailure(ctx context.Context, in *ReportSolanaParseFailureRequest, opts ...grpc.CallOption) (*ReportSolanaParseFailureResponse, error)
	ReportSourceFilterCompletion(ctx context.Context, in *ReportSourceFilterCompletionRequest, opts ...grpc.CallOption) (*ReportSourceFilterCompletionResponse, error)
	ReportSourceFilterFailure(ctx context.Context, in *ReportSourceFilterFailureRequest, opts ...grpc.CallOption) (*ReportSourceFilterFailureResponse, error)
	ReportAlertFilterCompletion(ctx context.Context, in *ReportAlertFilterCompletionRequest, opts ...grpc.CallOption) (*ReportAlertFilterCompletionResponse, error)
	ReportAlertFilterFailure(ctx context.Context, in *ReportAlertFilterFailureRequest, opts ...grpc.CallOption) (*ReportAlertFilterFailureResponse, error)
}

type fusionSchedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewFusionSchedulerClient(cc grpc.ClientConnInterface) FusionSchedulerClient {
	return &fusionSchedulerClient{cc}
}

func (c *fusionSchedulerClient) ReportEvmParseCompletion(ctx context.Context, in *ReportEvmParseCompletionRequest, opts ...grpc.CallOption) (*ReportEvmParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportEvmParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportEvmParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportEvmParseFailure(ctx context.Context, in *ReportEvmParseFailureRequest, opts ...grpc.CallOption) (*ReportEvmParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportEvmParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportEvmParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSuiParseCompletion(ctx context.Context, in *ReportSuiParseCompletionRequest, opts ...grpc.CallOption) (*ReportSuiParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSuiParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSuiParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSuiParseFailure(ctx context.Context, in *ReportSuiParseFailureRequest, opts ...grpc.CallOption) (*ReportSuiParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSuiParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSuiParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportEvmosParseCompletion(ctx context.Context, in *ReportEvmosParseCompletionRequest, opts ...grpc.CallOption) (*ReportEvmosParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportEvmosParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportEvmosParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportEvmosParseFailure(ctx context.Context, in *ReportEvmosParseFailureRequest, opts ...grpc.CallOption) (*ReportEvmosParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportEvmosParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportEvmosParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportOsmosisParseCompletion(ctx context.Context, in *ReportOsmosisParseCompletionRequest, opts ...grpc.CallOption) (*ReportOsmosisParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportOsmosisParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportOsmosisParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportOsmosisParseFailure(ctx context.Context, in *ReportOsmosisParseFailureRequest, opts ...grpc.CallOption) (*ReportOsmosisParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportOsmosisParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportOsmosisParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportOffchainParseCompletion(ctx context.Context, in *ReportOffchainParseCompletionRequest, opts ...grpc.CallOption) (*ReportOffchainParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportOffchainParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportOffchainParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportOffchainParseFailure(ctx context.Context, in *ReportOffchainParseFailureRequest, opts ...grpc.CallOption) (*ReportOffchainParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportOffchainParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportOffchainParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSolanaParseCompletion(ctx context.Context, in *ReportSolanaParseCompletionRequest, opts ...grpc.CallOption) (*ReportSolanaParseCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSolanaParseCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSolanaParseCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSolanaParseFailure(ctx context.Context, in *ReportSolanaParseFailureRequest, opts ...grpc.CallOption) (*ReportSolanaParseFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSolanaParseFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSolanaParseFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSourceFilterCompletion(ctx context.Context, in *ReportSourceFilterCompletionRequest, opts ...grpc.CallOption) (*ReportSourceFilterCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSourceFilterCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSourceFilterCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportSourceFilterFailure(ctx context.Context, in *ReportSourceFilterFailureRequest, opts ...grpc.CallOption) (*ReportSourceFilterFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSourceFilterFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportSourceFilterFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportAlertFilterCompletion(ctx context.Context, in *ReportAlertFilterCompletionRequest, opts ...grpc.CallOption) (*ReportAlertFilterCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportAlertFilterCompletionResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportAlertFilterCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fusionSchedulerClient) ReportAlertFilterFailure(ctx context.Context, in *ReportAlertFilterFailureRequest, opts ...grpc.CallOption) (*ReportAlertFilterFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportAlertFilterFailureResponse)
	err := c.cc.Invoke(ctx, FusionScheduler_ReportAlertFilterFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FusionSchedulerServer is the server API for FusionScheduler service.
// All implementations must embed UnimplementedFusionSchedulerServer
// for forward compatibility.
//
// Fusion endpoints are meant to be called from the FusionHost
// All Fusion endpoints require messages with a context_id
type FusionSchedulerServer interface {
	ReportEvmParseCompletion(context.Context, *ReportEvmParseCompletionRequest) (*ReportEvmParseCompletionResponse, error)
	ReportEvmParseFailure(context.Context, *ReportEvmParseFailureRequest) (*ReportEvmParseFailureResponse, error)
	ReportSuiParseCompletion(context.Context, *ReportSuiParseCompletionRequest) (*ReportSuiParseCompletionResponse, error)
	ReportSuiParseFailure(context.Context, *ReportSuiParseFailureRequest) (*ReportSuiParseFailureResponse, error)
	ReportEvmosParseCompletion(context.Context, *ReportEvmosParseCompletionRequest) (*ReportEvmosParseCompletionResponse, error)
	ReportEvmosParseFailure(context.Context, *ReportEvmosParseFailureRequest) (*ReportEvmosParseFailureResponse, error)
	ReportOsmosisParseCompletion(context.Context, *ReportOsmosisParseCompletionRequest) (*ReportOsmosisParseCompletionResponse, error)
	ReportOsmosisParseFailure(context.Context, *ReportOsmosisParseFailureRequest) (*ReportOsmosisParseFailureResponse, error)
	ReportOffchainParseCompletion(context.Context, *ReportOffchainParseCompletionRequest) (*ReportOffchainParseCompletionResponse, error)
	ReportOffchainParseFailure(context.Context, *ReportOffchainParseFailureRequest) (*ReportOffchainParseFailureResponse, error)
	ReportSolanaParseCompletion(context.Context, *ReportSolanaParseCompletionRequest) (*ReportSolanaParseCompletionResponse, error)
	ReportSolanaParseFailure(context.Context, *ReportSolanaParseFailureRequest) (*ReportSolanaParseFailureResponse, error)
	ReportSourceFilterCompletion(context.Context, *ReportSourceFilterCompletionRequest) (*ReportSourceFilterCompletionResponse, error)
	ReportSourceFilterFailure(context.Context, *ReportSourceFilterFailureRequest) (*ReportSourceFilterFailureResponse, error)
	ReportAlertFilterCompletion(context.Context, *ReportAlertFilterCompletionRequest) (*ReportAlertFilterCompletionResponse, error)
	ReportAlertFilterFailure(context.Context, *ReportAlertFilterFailureRequest) (*ReportAlertFilterFailureResponse, error)
	mustEmbedUnimplementedFusionSchedulerServer()
}

// UnimplementedFusionSchedulerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFusionSchedulerServer struct{}

func (UnimplementedFusionSchedulerServer) ReportEvmParseCompletion(context.Context, *ReportEvmParseCompletionRequest) (*ReportEvmParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportEvmParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportEvmParseFailure(context.Context, *ReportEvmParseFailureRequest) (*ReportEvmParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportEvmParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSuiParseCompletion(context.Context, *ReportSuiParseCompletionRequest) (*ReportSuiParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSuiParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSuiParseFailure(context.Context, *ReportSuiParseFailureRequest) (*ReportSuiParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSuiParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportEvmosParseCompletion(context.Context, *ReportEvmosParseCompletionRequest) (*ReportEvmosParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportEvmosParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportEvmosParseFailure(context.Context, *ReportEvmosParseFailureRequest) (*ReportEvmosParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportEvmosParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportOsmosisParseCompletion(context.Context, *ReportOsmosisParseCompletionRequest) (*ReportOsmosisParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportOsmosisParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportOsmosisParseFailure(context.Context, *ReportOsmosisParseFailureRequest) (*ReportOsmosisParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportOsmosisParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportOffchainParseCompletion(context.Context, *ReportOffchainParseCompletionRequest) (*ReportOffchainParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportOffchainParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportOffchainParseFailure(context.Context, *ReportOffchainParseFailureRequest) (*ReportOffchainParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportOffchainParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSolanaParseCompletion(context.Context, *ReportSolanaParseCompletionRequest) (*ReportSolanaParseCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSolanaParseCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSolanaParseFailure(context.Context, *ReportSolanaParseFailureRequest) (*ReportSolanaParseFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSolanaParseFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSourceFilterCompletion(context.Context, *ReportSourceFilterCompletionRequest) (*ReportSourceFilterCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSourceFilterCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportSourceFilterFailure(context.Context, *ReportSourceFilterFailureRequest) (*ReportSourceFilterFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSourceFilterFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportAlertFilterCompletion(context.Context, *ReportAlertFilterCompletionRequest) (*ReportAlertFilterCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportAlertFilterCompletion not implemented")
}
func (UnimplementedFusionSchedulerServer) ReportAlertFilterFailure(context.Context, *ReportAlertFilterFailureRequest) (*ReportAlertFilterFailureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportAlertFilterFailure not implemented")
}
func (UnimplementedFusionSchedulerServer) mustEmbedUnimplementedFusionSchedulerServer() {}
func (UnimplementedFusionSchedulerServer) testEmbeddedByValue()                         {}

// UnsafeFusionSchedulerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FusionSchedulerServer will
// result in compilation errors.
type UnsafeFusionSchedulerServer interface {
	mustEmbedUnimplementedFusionSchedulerServer()
}

func RegisterFusionSchedulerServer(s grpc.ServiceRegistrar, srv FusionSchedulerServer) {
	// If the following call panics, it indicates UnimplementedFusionSchedulerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FusionScheduler_ServiceDesc, srv)
}

func _FusionScheduler_ReportEvmParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEvmParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportEvmParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportEvmParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportEvmParseCompletion(ctx, req.(*ReportEvmParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportEvmParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEvmParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportEvmParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportEvmParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportEvmParseFailure(ctx, req.(*ReportEvmParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSuiParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSuiParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSuiParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSuiParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSuiParseCompletion(ctx, req.(*ReportSuiParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSuiParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSuiParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSuiParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSuiParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSuiParseFailure(ctx, req.(*ReportSuiParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportEvmosParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEvmosParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportEvmosParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportEvmosParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportEvmosParseCompletion(ctx, req.(*ReportEvmosParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportEvmosParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEvmosParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportEvmosParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportEvmosParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportEvmosParseFailure(ctx, req.(*ReportEvmosParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportOsmosisParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportOsmosisParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportOsmosisParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportOsmosisParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportOsmosisParseCompletion(ctx, req.(*ReportOsmosisParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportOsmosisParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportOsmosisParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportOsmosisParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportOsmosisParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportOsmosisParseFailure(ctx, req.(*ReportOsmosisParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportOffchainParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportOffchainParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportOffchainParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportOffchainParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportOffchainParseCompletion(ctx, req.(*ReportOffchainParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportOffchainParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportOffchainParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportOffchainParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportOffchainParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportOffchainParseFailure(ctx, req.(*ReportOffchainParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSolanaParseCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSolanaParseCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSolanaParseCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSolanaParseCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSolanaParseCompletion(ctx, req.(*ReportSolanaParseCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSolanaParseFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSolanaParseFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSolanaParseFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSolanaParseFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSolanaParseFailure(ctx, req.(*ReportSolanaParseFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSourceFilterCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSourceFilterCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSourceFilterCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSourceFilterCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSourceFilterCompletion(ctx, req.(*ReportSourceFilterCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportSourceFilterFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSourceFilterFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportSourceFilterFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportSourceFilterFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportSourceFilterFailure(ctx, req.(*ReportSourceFilterFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportAlertFilterCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAlertFilterCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportAlertFilterCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportAlertFilterCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportAlertFilterCompletion(ctx, req.(*ReportAlertFilterCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FusionScheduler_ReportAlertFilterFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAlertFilterFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FusionSchedulerServer).ReportAlertFilterFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FusionScheduler_ReportAlertFilterFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FusionSchedulerServer).ReportAlertFilterFailure(ctx, req.(*ReportAlertFilterFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FusionScheduler_ServiceDesc is the grpc.ServiceDesc for FusionScheduler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FusionScheduler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.scheduler.v1.FusionScheduler",
	HandlerType: (*FusionSchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportEvmParseCompletion",
			Handler:    _FusionScheduler_ReportEvmParseCompletion_Handler,
		},
		{
			MethodName: "ReportEvmParseFailure",
			Handler:    _FusionScheduler_ReportEvmParseFailure_Handler,
		},
		{
			MethodName: "ReportSuiParseCompletion",
			Handler:    _FusionScheduler_ReportSuiParseCompletion_Handler,
		},
		{
			MethodName: "ReportSuiParseFailure",
			Handler:    _FusionScheduler_ReportSuiParseFailure_Handler,
		},
		{
			MethodName: "ReportEvmosParseCompletion",
			Handler:    _FusionScheduler_ReportEvmosParseCompletion_Handler,
		},
		{
			MethodName: "ReportEvmosParseFailure",
			Handler:    _FusionScheduler_ReportEvmosParseFailure_Handler,
		},
		{
			MethodName: "ReportOsmosisParseCompletion",
			Handler:    _FusionScheduler_ReportOsmosisParseCompletion_Handler,
		},
		{
			MethodName: "ReportOsmosisParseFailure",
			Handler:    _FusionScheduler_ReportOsmosisParseFailure_Handler,
		},
		{
			MethodName: "ReportOffchainParseCompletion",
			Handler:    _FusionScheduler_ReportOffchainParseCompletion_Handler,
		},
		{
			MethodName: "ReportOffchainParseFailure",
			Handler:    _FusionScheduler_ReportOffchainParseFailure_Handler,
		},
		{
			MethodName: "ReportSolanaParseCompletion",
			Handler:    _FusionScheduler_ReportSolanaParseCompletion_Handler,
		},
		{
			MethodName: "ReportSolanaParseFailure",
			Handler:    _FusionScheduler_ReportSolanaParseFailure_Handler,
		},
		{
			MethodName: "ReportSourceFilterCompletion",
			Handler:    _FusionScheduler_ReportSourceFilterCompletion_Handler,
		},
		{
			MethodName: "ReportSourceFilterFailure",
			Handler:    _FusionScheduler_ReportSourceFilterFailure_Handler,
		},
		{
			MethodName: "ReportAlertFilterCompletion",
			Handler:    _FusionScheduler_ReportAlertFilterCompletion_Handler,
		},
		{
			MethodName: "ReportAlertFilterFailure",
			Handler:    _FusionScheduler_ReportAlertFilterFailure_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/scheduler/v1/scheduler.proto",
}
