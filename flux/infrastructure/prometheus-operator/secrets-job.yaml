---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus-operator-secret-sync
  namespace: prometheus
  labels:
    app: prometheus-operator
    component: secret-sync
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus-operator-secret-sync
  labels:
    app: prometheus-operator
    component: secret-sync
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-operator-secret-sync
  labels:
    app: prometheus-operator
    component: secret-sync
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus-operator-secret-sync
subjects:
- kind: ServiceAccount
  name: prometheus-operator-secret-sync
  namespace: prometheus
---
apiVersion: batch/v1
kind: Job
metadata:
  name: prometheus-operator-secret-sync
  namespace: prometheus
  labels:
    app: prometheus-operator
    component: secret-sync
  annotations:
    # Prevent Flux from trying to reconcile this Job after creation
    # Jobs have immutable spec.template, so reconciliation will fail
    kustomize.toolkit.fluxcd.io/prune: disabled
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 86400
  template:
    metadata:
      labels:
        app: prometheus-operator
        component: secret-sync
    spec:
      serviceAccountName: prometheus-operator-secret-sync
      restartPolicy: Never
      containers:
      - name: sync
        image: localhost:5001/kubectl:v1.34.0
        imagePullPolicy: IfNotPresent
        env:
        - name: SOURCE_NAMESPACE
          value: flux-system
        - name: TARGET_NAMESPACE
          value: prometheus
        - name: SECRET_NAMES
          value: "prometheus"
        command:
        - /bin/bash
        - -c
        - |
          set -euo pipefail

          echo "Syncing secrets into ${TARGET_NAMESPACE}"
          for secret in ${SECRET_NAMES}; do
            echo "Processing ${secret}"
            kubectl get secret "${secret}" -n "${SOURCE_NAMESPACE}" -o json \
              | jq --arg target "${TARGET_NAMESPACE}" '
                  .metadata.namespace = $target
                  | .metadata.labels = (.metadata.labels // {})
                  | .metadata.annotations = (.metadata.annotations // {})
                  | del(.metadata.uid,
                        .metadata.resourceVersion,
                        .metadata.creationTimestamp,
                        .metadata.managedFields,
                        .metadata.ownerReferences)
                  | if .data["admin-user"] == null then
                      .data["admin-user"] = "YWRtaW4="  # base64("admin")
                    else
                      .
                    end
                ' \
              | kubectl apply -f -
          done
          
          echo ""
          echo "Ensuring grafana-secret-key exists in prometheus secret"
          # Check if grafana-secret-key already exists in the prometheus secret
          EXISTING_KEY=$(kubectl get secret prometheus -n "${TARGET_NAMESPACE}" -o jsonpath='{.data.grafana-secret-key}' 2>/dev/null || echo "")
          if [ -z "${EXISTING_KEY}" ]; then
            echo "Generating new grafana-secret-key..."
            # Generate a cryptographically secure 32-byte random key (base64 encoded)
            GRAFANA_SECRET_KEY=$(openssl rand -base64 32)
            # Patch the prometheus secret to add the grafana-secret-key
            kubectl patch secret prometheus -n "${TARGET_NAMESPACE}" --type='json' \
              -p="[{\"op\": \"add\", \"path\": \"/data/grafana-secret-key\", \"value\": \"$(echo -n "${GRAFANA_SECRET_KEY}" | base64 -w0)\"}]"
            echo "✅ grafana-secret-key added to prometheus secret"
          else
            echo "✅ grafana-secret-key already exists in prometheus secret"
          fi
          
          echo ""
          echo "Creating alertmanager-pagerduty secret from prometheus secret"
          # Check if prometheus secret exists and has pagerduty-service-key
          if kubectl get secret prometheus -n "${TARGET_NAMESPACE}" &>/dev/null; then
            PAGERDUTY_KEY=$(kubectl get secret prometheus -n "${TARGET_NAMESPACE}" -o jsonpath='{.data.pagerduty-service-key}' 2>/dev/null | base64 -d)
            if [ -n "${PAGERDUTY_KEY}" ]; then
              echo "Creating alertmanager-pagerduty secret..."
              kubectl create secret generic alertmanager-pagerduty \
                --from-literal=service-key="${PAGERDUTY_KEY}" \
                --namespace="${TARGET_NAMESPACE}" \
                --dry-run=client -o yaml | kubectl apply -f -
              echo "✅ alertmanager-pagerduty secret created"
            else
              echo "⚠️  pagerduty-service-key not found in prometheus secret, skipping alertmanager-pagerduty creation"
            fi
          else
            echo "⚠️  prometheus secret not found in ${TARGET_NAMESPACE}, skipping alertmanager-pagerduty creation"
          fi
          
          echo "Forcing rollout of all deployments in ${TARGET_NAMESPACE}"
          for deployment in $(kubectl get deployments -n "${TARGET_NAMESPACE}" -o jsonpath='{.items[*].metadata.name}'); do
            echo "Rolling out deployment ${deployment}"
            kubectl rollout restart deployment "${deployment}" -n "${TARGET_NAMESPACE}"
          done
          
          echo "Waiting for rollouts to complete"
          for deployment in $(kubectl get deployments -n "${TARGET_NAMESPACE}" -o jsonpath='{.items[*].metadata.name}'); do
            echo "Waiting for deployment ${deployment} to be ready"
            kubectl rollout status deployment "${deployment}" -n "${TARGET_NAMESPACE}" --timeout=5m || echo "Warning: Deployment ${deployment} rollout did not complete within timeout"
          done
          
          echo "✅ Secret sync and rollout complete"

