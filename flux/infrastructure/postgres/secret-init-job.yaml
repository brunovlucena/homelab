---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: postgres-secret-init
  namespace: postgres
  labels:
    app: postgres
    component: secret-init
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: postgres-secret-init
  labels:
    app: postgres
    component: secret-init
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: postgres-secret-init
  labels:
    app: postgres
    component: secret-init
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: postgres-secret-init
subjects:
- kind: ServiceAccount
  name: postgres-secret-init
  namespace: postgres
---
apiVersion: batch/v1
kind: Job
metadata:
  name: postgres-secret-init
  namespace: postgres
  labels:
    app: postgres
    component: secret-init
  annotations:
    # Prevent Flux from trying to reconcile this Job after creation
    # Jobs have immutable spec.template, so reconciliation will fail
    kustomize.toolkit.fluxcd.io/prune: disabled
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 86400
  template:
    metadata:
      labels:
        app: postgres
        component: secret-init
    spec:
      serviceAccountName: postgres-secret-init
      restartPolicy: Never
      containers:
      - name: init
        image: localhost:5001/kubectl:v1.34.0
        imagePullPolicy: IfNotPresent
        env:
        - name: SOURCE_NAMESPACE
          value: flux-system
        - name: TARGET_NAMESPACE
          value: postgres
        - name: SECRET_NAME
          value: homepage
        command:
        - /bin/bash
        - -c
        - |
          set -euo pipefail

          echo "Syncing ${SECRET_NAME} secret from ${SOURCE_NAMESPACE} to ${TARGET_NAMESPACE} as postgres"
          if ! kubectl get secret "${SECRET_NAME}" -n "${SOURCE_NAMESPACE}" &>/dev/null; then
            echo "Error: ${SECRET_NAME} secret not found in ${SOURCE_NAMESPACE} namespace"
            exit 1
          fi

          POSTGRES_PASSWORD=$(kubectl get secret "${SECRET_NAME}" -n "${SOURCE_NAMESPACE}" -o jsonpath="{.data.homepage-postgres-password}" | base64 -d)
          if [ -z "${POSTGRES_PASSWORD}" ]; then
            echo "Error: homepage-postgres-password key not found in ${SECRET_NAME} secret"
            exit 1
          fi

          kubectl create secret generic postgres \
            --from-literal=password="${POSTGRES_PASSWORD}" \
            --namespace="${TARGET_NAMESPACE}" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "Synced ${SECRET_NAME} secret as postgres with password key"

          echo "Forcing rollout of all deployments in ${TARGET_NAMESPACE}"
          for deployment in $(kubectl get deployments -n "${TARGET_NAMESPACE}" -o jsonpath='{.items[*].metadata.name}'); do
            echo "Rolling out deployment ${deployment}"
            kubectl rollout restart deployment "${deployment}" -n "${TARGET_NAMESPACE}"
          done

          echo "Waiting for rollouts to complete"
          for deployment in $(kubectl get deployments -n "${TARGET_NAMESPACE}" -o jsonpath='{.items[*].metadata.name}'); do
            echo "Waiting for deployment ${deployment} to be ready"
            kubectl rollout status deployment "${deployment}" -n "${TARGET_NAMESPACE}" --timeout=5m || echo "Warning: Deployment ${deployment} rollout did not complete within timeout"
          done

          echo "Secret init and rollout complete"

