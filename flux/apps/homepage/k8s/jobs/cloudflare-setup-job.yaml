# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
#  ğŸš€ HOMEPAGE CLOUDFLARE SETUP JOB - Automate Cloudflare Performance Configuration
#
#  Purpose: Automatically configure Cloudflare Page Rules, Speed settings, and Argo Smart Routing
#  Settings:
#    - Page Rules: Cache JavaScript, Images, and HTML with optimized TTLs
#    - Speed Optimization: Enable Auto Minify for JS, CSS, and HTML
#    - Argo Smart Routing: Enable intelligent routing for 20-40% latency reduction (BVL-23)
#
#  Uses: Cloudflare API token from cloudflare-tunnel namespace secret
#
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

# ServiceAccount and RBAC for Cloudflare setup job
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cloudflare-setup
  namespace: homepage
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cloudflare-setup
  namespace: homepage
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cloudflare-setup-read-secrets
  namespace: cloudflare-tunnel
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cloudflare-setup
  namespace: homepage
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cloudflare-setup
subjects:
- kind: ServiceAccount
  name: cloudflare-setup
  namespace: homepage
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cloudflare-setup-read-secrets
  namespace: cloudflare-tunnel
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cloudflare-setup-read-secrets
subjects:
- kind: ServiceAccount
  name: cloudflare-setup
  namespace: homepage
---
# Job to configure Cloudflare settings
apiVersion: batch/v1
kind: Job
metadata:
  name: cloudflare-setup
  namespace: homepage
  labels:
    app.kubernetes.io/name: homepage
    app.kubernetes.io/component: cloudflare-setup
spec:
  ttlSecondsAfterFinished: 86400  # Keep for 24 hours
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: homepage
        app.kubernetes.io/component: cloudflare-setup
    spec:
      restartPolicy: Never
      serviceAccountName: cloudflare-setup
      initContainers:
        - name: sync-cloudflare-secret
          image: localhost:5001/kubectl:v1.34.0
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "ğŸ” Syncing Cloudflare secret from cloudflare-tunnel namespace..."
              
              # Wait for secret in cloudflare-tunnel namespace
              MAX_WAIT=60
              WAITED=0
              while ! kubectl get secret cloudflare -n cloudflare-tunnel &>/dev/null; do
                if [ $WAITED -ge $MAX_WAIT ]; then
                  echo "âŒ Timeout waiting for cloudflare secret in cloudflare-tunnel namespace"
                  exit 1
                fi
                echo "â³ Waiting for cloudflare secret in cloudflare-tunnel namespace... (${WAITED}s/${MAX_WAIT}s)"
                sleep 2
                WAITED=$((WAITED + 2))
              done
              
              echo "ğŸ“‹ Found secret in cloudflare-tunnel namespace, syncing to homepage..."
              
              # Extract API token (prefer cloudflare-api-token, fallback to cloudflare-api-key)
              API_TOKEN=$(kubectl get secret cloudflare -n cloudflare-tunnel -o jsonpath='{.data.cloudflare-api-token}' 2>/dev/null | base64 -d || \
                         kubectl get secret cloudflare -n cloudflare-tunnel -o jsonpath='{.data.cloudflare-api-key}' 2>/dev/null | base64 -d || echo "")
              
              if [ -z "${API_TOKEN}" ]; then
                echo "âŒ Error: Could not extract Cloudflare API token from secret"
                echo "   Expected key: cloudflare-api-token or cloudflare-api-key"
                exit 1
              fi
              
              # Create secret in homepage namespace with API token
              kubectl create secret generic cloudflare-api-token \
                --from-literal=api-token="${API_TOKEN}" \
                --namespace=homepage \
                --dry-run=client -o yaml | kubectl apply -f -
              
              echo "âœ… Secret cloudflare-api-token synced to homepage namespace"
      containers:
        - name: setup
          image: curlimages/curl:latest
          command:
            - /bin/sh
            - -c
            - |
              set -euo pipefail
              
              echo "ğŸš€ Starting Cloudflare Performance Setup for lucena.cloud"
              
              # Get Cloudflare API token from environment
              echo "ğŸ” Retrieving Cloudflare API token..."
              API_TOKEN="${CLOUDFLARE_API_TOKEN}"
              
              if [ -z "${API_TOKEN}" ]; then
                echo "âŒ Error: Cloudflare API token not found in secret"
                exit 1
              fi
              
              echo "âœ… Retrieved Cloudflare API token"
              
              # Set domain
              DOMAIN="lucena.cloud"
              API_BASE="https://api.cloudflare.com/client/v4"
              
              # Get Zone ID
              echo "ğŸ” Getting Zone ID for ${DOMAIN}..."
              ZONE_RESPONSE=$(curl -s -X GET "${API_BASE}/zones?name=${DOMAIN}" \
                -H "Authorization: Bearer ${API_TOKEN}" \
                -H "Content-Type: application/json")
              
              ZONE_ID=$(echo "${ZONE_RESPONSE}" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
              
              if [ -z "${ZONE_ID}" ]; then
                echo "âŒ Error: Could not find zone ID for ${DOMAIN}"
                echo "Response: ${ZONE_RESPONSE}"
                exit 1
              fi
              
              echo "âœ… Found Zone ID: ${ZONE_ID}"
              
              # Helper function to check API response
              check_api_response() {
                local response_body="$1"
                local http_code="$2"
                
                if [ "${http_code}" != "200" ] && [ "${http_code}" != "201" ]; then
                  echo "   âŒ HTTP Error ${http_code}"
                  return 1
                fi
                
                local success=$(echo "${response_body}" | grep -o '"success":[^,}]*' | cut -d':' -f2 | tr -d ' ' || echo "false")
                if [ "${success}" != "true" ]; then
                  local errors=$(echo "${response_body}" | grep -o '"message":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "Unknown error")
                  echo "   âš ï¸  API Warning: ${errors}"
                  return 1
                fi
                return 0
              }
              
              # Function to create or update Page Rule
              create_or_update_page_rule() {
                local pattern="$1"
                local cache_level="$2"
                local edge_ttl="$3"
                local browser_ttl="$4"
                local rule_description="$5"
                
                echo ""
                echo "ğŸ“‹ Configuring Page Rule: ${rule_description}"
                echo "   Pattern: ${pattern}"
                echo "   Cache Level: ${cache_level}"
                echo "   Edge Cache TTL: ${edge_ttl}"
                echo "   Browser Cache TTL: ${browser_ttl}"
                
                # Check if rule already exists by listing all rules
                EXISTING_RULES=$(curl -s -X GET "${API_BASE}/zones/${ZONE_ID}/pagerules?match=all" \
                  -H "Authorization: Bearer ${API_TOKEN}" \
                  -H "Content-Type: application/json")
                
                # Try to find existing rule by pattern
                # Escape pattern for grep (escape special chars like *, /, etc.)
                ESCAPED_PATTERN=$(echo "${pattern}" | sed 's/\./\\./g; s/\*/\\*/g; s/\//\\\//g')
                
                # Look for rule ID near our pattern in the JSON response
                # Cloudflare API returns rules with targets containing the pattern value
                EXISTING_RULE_ID=$(echo "${EXISTING_RULES}" | \
                  grep -A 10 -B 5 "\"value\":\"${ESCAPED_PATTERN}\"" | \
                  grep '"id":"[^"]*"' | \
                  head -1 | \
                  cut -d'"' -f4 || echo "")
                
                # Build actions array
                ACTIONS="[{\"id\":\"cache_level\",\"value\":\"${cache_level}\"},{\"id\":\"edge_cache_ttl\",\"value\":${edge_ttl}}"
                
                # Add browser_cache_ttl only if it's not "respect_existing_headers"
                if [ "${browser_ttl}" != "respect_existing_headers" ]; then
                  ACTIONS="${ACTIONS},{\"id\":\"browser_cache_ttl\",\"value\":${browser_ttl}}"
                fi
                
                ACTIONS="${ACTIONS}]"
                
                # Create or update rule
                if [ -n "${EXISTING_RULE_ID}" ]; then
                  echo "   â†» Updating existing Page Rule (ID: ${EXISTING_RULE_ID})..."
                  RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH "${API_BASE}/zones/${ZONE_ID}/pagerules/${EXISTING_RULE_ID}" \
                    -H "Authorization: Bearer ${API_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d "{\"targets\":[{\"target\":\"url\",\"constraint\":{\"operator\":\"matches\",\"value\":\"${pattern}\"}}],\"actions\":${ACTIONS},\"priority\":1,\"status\":\"active\"}")
                else
                  echo "   â• Creating new Page Rule..."
                  RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${API_BASE}/zones/${ZONE_ID}/pagerules" \
                    -H "Authorization: Bearer ${API_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d "{\"targets\":[{\"target\":\"url\",\"constraint\":{\"operator\":\"matches\",\"value\":\"${pattern}\"}}],\"actions\":${ACTIONS},\"priority\":1,\"status\":\"active\"}")
                fi
                
                # Extract HTTP status code and response body
                HTTP_CODE=$(echo "${RESPONSE}" | tail -1)
                RESPONSE_BODY=$(echo "${RESPONSE}" | head -n -1)
                
                if check_api_response "${RESPONSE_BODY}" "${HTTP_CODE}"; then
                  echo "   âœ… Page Rule configured successfully"
                else
                  echo "   âš ï¸  Page Rule configuration had issues"
                  echo "   Response: ${RESPONSE_BODY}"
                fi
              }
              
              # Configure Page Rules
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "ğŸ“ Step 1: Configuring Page Rules"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              
              # Rule 1: Cache JavaScript Files (1 month)
              create_or_update_page_rule \
                "${DOMAIN}/*.js" \
                "cache_everything" \
                "2592000" \
                "respect_existing_headers" \
                "Cache JavaScript Files"
              
              # Rule 2: Cache Images (31 days - free tier max)
              create_or_update_page_rule \
                "${DOMAIN}/storage/*" \
                "cache_everything" \
                "2678400" \
                "2678400" \
                "Cache Images"
              
              # Rule 3: Cache HTML (2 hours - free tier min)
              create_or_update_page_rule \
                "${DOMAIN}/" \
                "cache_everything" \
                "7200" \
                "respect_existing_headers" \
                "Cache HTML"
              
              # Configure Speed Optimization (Auto Minify)
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "âš¡ Step 2: Configuring Speed Optimization (Auto Minify)"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              
              echo "ğŸ“‹ Enabling Auto Minify for JavaScript, CSS, and HTML..."
              
              MINIFY_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH "${API_BASE}/zones/${ZONE_ID}/settings/minify" \
                -H "Authorization: Bearer ${API_TOKEN}" \
                -H "Content-Type: application/json" \
                -d '{"value":{"js":"on","css":"on","html":"on"}}')
              
              MINIFY_HTTP_CODE=$(echo "${MINIFY_RESPONSE}" | tail -1)
              MINIFY_RESPONSE_BODY=$(echo "${MINIFY_RESPONSE}" | head -n -1)
              
              if check_api_response "${MINIFY_RESPONSE_BODY}" "${MINIFY_HTTP_CODE}"; then
                echo "âœ… Auto Minify enabled for JavaScript, CSS, and HTML"
              else
                echo "âš ï¸  Auto Minify configuration had issues - check response above"
              fi
              
              # Configure Argo Smart Routing (BVL-23)
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "ğŸš€ Step 3: Enabling Argo Smart Routing"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo ""
              echo "ğŸ“‹ Argo Smart Routing provides intelligent routing to reduce latency by 20-40%"
              echo "   - FREE tier: 1GB/month included"
              echo "   - USA users: 50-100ms faster on cache misses"
              echo "   - Brazil users: 20-50ms faster"
              echo ""
              
              # First check current Argo Smart Routing status
              echo "ğŸ” Checking current Argo Smart Routing status..."
              ARGO_STATUS_RESPONSE=$(curl -s -X GET "${API_BASE}/zones/${ZONE_ID}/argo/smart_routing" \
                -H "Authorization: Bearer ${API_TOKEN}" \
                -H "Content-Type: application/json")
              
              CURRENT_ARGO_STATUS=$(echo "${ARGO_STATUS_RESPONSE}" | grep -o '"value":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
              echo "   Current status: ${CURRENT_ARGO_STATUS}"
              
              if [ "${CURRENT_ARGO_STATUS}" = "on" ]; then
                echo "âœ… Argo Smart Routing is already enabled!"
              else
                echo "ğŸ“‹ Enabling Argo Smart Routing..."
                
                ARGO_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH "${API_BASE}/zones/${ZONE_ID}/argo/smart_routing" \
                  -H "Authorization: Bearer ${API_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d '{"value":"on"}')
                
                ARGO_HTTP_CODE=$(echo "${ARGO_RESPONSE}" | tail -1)
                ARGO_RESPONSE_BODY=$(echo "${ARGO_RESPONSE}" | head -n -1)
                
                if check_api_response "${ARGO_RESPONSE_BODY}" "${ARGO_HTTP_CODE}"; then
                  echo "âœ… Argo Smart Routing enabled successfully!"
                  echo "   Note: It may take 5-10 minutes for changes to propagate"
                else
                  echo "âš ï¸  Argo Smart Routing configuration had issues"
                  echo "   This feature may require a paid plan or manual enablement"
                  echo "   Go to: Cloudflare Dashboard â†’ Network â†’ Argo Smart Routing"
                fi
              fi
              
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "âœ… Cloudflare Performance Setup Complete!"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo ""
              echo "ğŸ“Š Configured Settings:"
              echo "   âœ… Page Rule 1: ${DOMAIN}/*.js (Cache Everything, 1 month)"
              echo "   âœ… Page Rule 2: ${DOMAIN}/storage/* (Cache Everything, 1 year)"
              echo "   âœ… Page Rule 3: ${DOMAIN}/ (Cache Everything, 15 minutes)"
              echo "   âœ… Auto Minify: JavaScript, CSS, HTML (ON)"
              echo "   âœ… Argo Smart Routing: ON (20-40% latency reduction)"
              echo ""
              echo "ğŸš€ Expected Performance Improvements:"
              echo "   - USA users: 50-100ms faster on cache misses"
              echo "   - Brazil users: 20-50ms faster"
              echo "   - Overall latency: 20-40% reduction via Argo Smart Routing"
              echo ""
              echo "ğŸ‰ Setup completed successfully! Changes may take 5-10 minutes to propagate."
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflare-api-token
                  key: api-token
